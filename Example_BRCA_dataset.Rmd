---
title: "EMR Workshop 2023: Removing unwanted variation from large-scale RNA sequencing data with RUV-PRPS"
author:
- name: Marie Trussart and Ramyar Molania
  affiliation: Speed and Papenfuss Lab, Bioinformatics, WEHI.
  url: https://www.wehi.edu.au/people/tony-papenfuss
date: "03-05-2023"
output:
  html_document:
    toc_depth: '3'
    df_print: paged
  html_document2:
    df_print: paged
  rmdformats::readthedown:
    code_folding: hide
    gallery: yes
    highlight: tango
    lightbox: yes
    self_contained: yes
    thumbnails: no
    number_sections: yes
    toc_depth: 3
    use_bookdown: yes
params:
  update_date: !r paste("Last updated on:", Sys.Date())
editor_options:
  chunk_output_type: console
---
`r params$update_date`

<style type="text/css">
h1.title {
  font-size: 28px;
  color: DarkRed;
}
h1 { /* Header 1 */
  font-size: 24px;
  color: DarkBlue;
}
h2 { /* Header 2 */
    font-size: 20px;
  color: DarkBlue;
}
h3 { /* Header 3 */
    font-size: 18px;
  color: DarkBlue;
}
h4 { /* Header 3 */
    font-size: 16px;
  color: DarkBlue;
}
</style>

<style>
body {
text-align: justify}
</style>

<style>
p.caption {
  font-size: 1.6em;
  font-style: italic;
  color: black;
  text-align: center;
}
</style>

## Setup 

We provided here a vignette that explains step by step how to load and normalise large-scale RNA sequencing data using our R Package `RUVPRPS` and also how to visualise the diagnostic plots before and after RUVIII-PRPS normalisation.\
First of all we need to install and load all the packages:

```{r knitr_init, echo=FALSE, results="asis"}
library(RUVPRPS)
library(kunstomverse)
library(SummarizedExperiment)
library(ggplot2)
library(BiocSingular)
library(ggpubr)
library(cowplot)
library(scales)
library(RColorBrewer)
library(grDevices)
library(gridExtra)
library(wesanderson)
library(dplyr)
library(tidyr)
library(parallel)
library(cluster)
library(mclust)
library(matrixTests)
library(fastDummies)
library(stats)
library(Rfast)
library(matrixStats)
library(ruv)
library(Matrix)
library(ComplexHeatmap)
library(genefu)

#=================== ANOVA =================
# Analysis of variance between individual genes and variables 
## expr.data is gene expression matrix genes by samples
## is.log is logical factor indicating whether the data is log transformed or not
## n.cores is number of cpus used for mclapply parallelization
.Ftest <- function(
  data, 
  variable, 
  is.log, 
  n.cores
)
{
  average.exp <- log2(rowMeans(data))
  if(is.log) data <- data
  else data <- log2(data + 1)
  f.test <- parallel::mclapply(
    1:nrow(data),
    function(x) {
      MASS::dropterm(lm(data[x , ] ~ variable), test = 'F')[c(5:6)]
    }
    , mc.cores = n.cores)
  f.test <- data.frame(
    Genes = row.names(data),
    FValue = round(unlist(
      lapply(
        f.test, 
        function(x) x$`F Value`[2])), digits = 4
    ) ,
    PValue = unlist(lapply(
      f.test, 
      function(x) x$`Pr(F)`[2])
    ),
    Adj.PValue = p.adjust(unlist(lapply(
      f.test, 
      function(x) x$`Pr(F)`[2])), method = 'BH'
    ),
    Mean = round(average.exp, digits = 2)
  )
  return(f.test)
}

.corr.gene.variable <- function(
  expr.data, 
  is.log, 
  variable, 
  method, 
  n.cores, 
  group)
{
  if(is.log) expr.data <- expr.data
  else expr.data <- log2(expr.data + 1)
  rho <- parallel::mclapply(
    1:nrow(expr.data),
    function(x){
      round(cor.test(
        x = expr.data[x, ], 
        y = variable, 
        method = method)[[4]], 6)},
    mc.cores = n.cores
  )
  pval <- parallel::mclapply(
    1:nrow(expr.data),
    function(x){
      cor.test(
        x = expr.data[x, ], 
        y = variable,
        method = method)[[3]]},
    mc.cores = n.cores)
  
  results <- data.frame(
    genes = row.names(expr.data),
    rho = unlist(rho), 
    pvalue = unlist(pval), 
    adj.pvalue = p.adjust(unlist(pval), 'BH')
  )
  colnames(results) <- paste(
    group, 
    colnames(results), 
    sep = '_'
  )
  return(results)
}
#=================== PCA =================
# Principal component analysis using singular value decomposition (SVD)
## data: gene expression matrix genes by samples
## is.log:  logical factor indicating whether the data is log transformed or not
.pca <- function(data, is.log) {
  if (is.log)
    data <- data
  else
    data <- log2(data + 1)
  svd <- base::svd(scale(
    x = t(data),
    center = TRUE,
    scale = FALSE
  ))
  percent <- svd$d ^ 2 / sum(svd$d ^ 2) * 100
  percent <-
    sapply(seq_along(percent),
           function(i) {
             round(percent[i], 1)
           })
  return(list(
    sing.val = svd,
    variation = percent))
}
# Fast principal component analysis
## data: gene expression matrix genes by samples
## nPcs: integer scalar specifying the number of singular values to return
## is.log:  logical factor indicating whether the data is log transformed or not
fast.pca <- function(data, nPcs, is.log) {
  if(is.log){
    data <- data
  }else{
    data <- log2(data + 1)
  }
  svd <- BiocSingular::runSVD(
    x = t(data),
    k = nPcs,
    BSPARAM = BiocSingular::bsparam(),
    center = TRUE,
    scale = FALSE
  )
  percent <- svd$d^2/sum(svd$d^2)*100
  percent <-
    sapply(
      seq_along(percent),
      function(i) {round(percent[i], 1)})
  return(list(
    sing.val = svd,
    variation = percent))
}

#=================== PCA plot with density  =================
## PCS: pca from 
## pc.var: pca variation output from .pca() function 
## group.legend name
## group: logical factor to color the PCA plot
## color: to color the points 
## strokeSize: stroke size of the points
## pointSize: size of the points
## strokeColor: color of the points stroke
## alpha
.scatter.density.pc <- function(
  pcs, 
  pc.var, 
  group.name, 
  group, 
  color, 
  strokeSize, 
  pointSize, 
  strokeColor,
  alpha,
  title
){
  pair.pcs <- utils::combn(ncol(pcs), 2)
  pList <- list()
  for(i in 1:ncol(pair.pcs)){
    if(i == 1){
      x <- pair.pcs[1,i]
      y <- pair.pcs[2,i]
      p <- ggplot(mapping = aes(
        x = pcs[,x], 
        y = pcs[,y], 
        fill = group)) +
        xlab(paste0('PC', x, ' (', pc.var[x], '%)')) +
        ylab(paste0('PC', y, ' (', pc.var[y], '%)')) +
        geom_point(
          aes(fill = group), 
          pch = 21, 
          color = strokeColor, 
          stroke = strokeSize, 
          size = pointSize,
          alpha = alpha) +
        scale_x_continuous(breaks = scales::pretty_breaks(n = 5)) +
        scale_y_continuous(breaks = scales::pretty_breaks(n = 5)) +
        ggtitle(title) +
        theme(
          legend.position = "right",
          panel.background = element_blank(), 
          axis.line = element_line(colour = "black", size = 1.1),
          legend.background = element_blank(),
          legend.text = element_text(size = 12),
          legend.title = element_text(size = 14),
          legend.key = element_blank(),
          axis.text.x = element_text(size = 10),
          axis.text.y = element_text(size = 10),
          axis.title.x = element_text(size = 14),
          axis.title.y = element_text(size = 14)) +
        guides(fill = guide_legend(override.aes = list(size = 4))) + 
        scale_fill_manual(name = group.name, values = color)
      
      le <- ggpubr::get_legend(p)
    }else{
      x <- pair.pcs[1,i]
      y <- pair.pcs[2,i]
      p <- ggplot(mapping = aes(
        x = pcs[,x], 
        y = pcs[,y], 
        fill = group)) +
        xlab(paste0('PC', x, ' (',pc.var[x],  '%)')) +
        ylab(paste0('PC', y, ' (',pc.var[y], '%)')) +
        geom_point(
          aes(fill = group), 
          pch = 21, 
          color = strokeColor, 
          stroke = strokeSize,
          size = pointSize,
          alpha = alpha) +
        scale_x_continuous(breaks = scales::pretty_breaks(n = 5)) +
        scale_y_continuous(breaks = scales::pretty_breaks(n = 5)) +
        theme(
          panel.background = element_blank(), 
          axis.line = element_line(colour = "black", size = 1.1),
          legend.position = "none",
          axis.text.x = element_text(size = 10),
          axis.text.y = element_text(size = 10),
          axis.title.x = element_text(size = 14),
          axis.title.y = element_text(size = 14)) +
        scale_fill_manual(values = color, name = group.name)
    }
    p <- p + theme(legend.position = "none")
    xdens <- cowplot::axis_canvas(p, axis = "x")+
      geom_density(
        mapping = aes(
          x = pcs[,x], 
          fill = group),
        alpha = 0.7, 
        size = 0.2
      ) +
      theme(legend.position = "none") +
      scale_fill_manual(values = color)
    
    ydens <- cowplot::axis_canvas(
      p, 
      axis = "y", 
      coord_flip = TRUE) +
      geom_density(
        mapping = aes(
          x = pcs[,y],
          fill = group),
        alpha = 0.7,
        size = 0.2) +
      theme(legend.position = "none") +
      scale_fill_manual(name = group.name, values = color) +
      coord_flip()
    
    p1 <- insert_xaxis_grob(
      p,
      xdens,
      grid::unit(.2, "null"),
      position = "top"
    )
    p2 <- insert_yaxis_grob(
      p1,
      ydens,
      grid::unit(.2, "null"),
      position = "right"
    )
    pList[[i]] <- ggdraw(p2)
  }
  pList[[i+1]] <- le
  return(pList)
}

#====Genefu PAM50 classifier=====
.pam50.geneFu <- function(expr.data, gene.annot){
  row.names(expr.data)[row.names(expr.data) == 'NDC80'] <- 'KNTC2'
  row.names(expr.data)[row.names(expr.data) == 'NUF2'] <- 'CDCA1'
  row.names(expr.data)[row.names(expr.data) == 'ORC6'] <-'ORC6L'
  # load('pam50.rda')
  # load('pam50.robust.rda')
  
  # print(intersect(
  #   row.names(expr.data),
  #   row.names(pam50$centroids)
  # ))
  gene.annot$gene_name.[gene.annot$gene_name. == 'NDC80'] <-'KNTC2'
  gene.annot$gene_name.[gene.annot$gene_name. == 'NUF2'] <-'CDCA1'
  gene.annot$gene_name.[gene.annot$gene_name. == 'ORC6'] <-'ORC6L'
  colnames(gene.annot)[28] <- 'EntrezGene.ID'
  colnames(gene.annot)[9] <- 'probe'
  genefu::molecular.subtyping(
    sbt.model = "pam50",
    data = t(expr.data),
    annot = gene.annot,
    do.mapping = TRUE)
}


#=================== Survival analysis  =================
# This function depends on the below libraries 
# This function looks at the associations between different variables and survival outcome. These variables can be one of the below options that stratifies samples for survival analysis:

# expr : expression of a gene, will be split based on 33%-tile and 66%-tile (e.g. low, medium, high)\n
# score : score of a single signatre, will be split based on 33%-tile and 66%-tile (low, medium, high)\n
# covariate : A continouse covariate (e.g. age), will be split based on 33%-tile and 66%-tile (low, medium, high)\n
# score_expr : stratifies samples based on scores from a signature (high and low) and expression of a gene (high and low)\n
# covariate_expr : startifies samples according to covariate (age; high and low) and expression of a gene (high and low)\n
# score_covariate: stratifies samples according to scores from a single signature (high and low) and covariate (age; high and low)\n
# expr_expr : stratifies samples according to expression of two genes (high gene1/high gene2, high gene1/low gene2, etc)\n
# score_score : stratifies samples according to scores obtained from two signatures (high score1/high score2, high score1/low score2, etc)

survival_plot <- function(
  data = exprData,
  stratify = "score_score",
  annot = newAnnot,
  scoreCol =  c("TRM TGFb IL2 Sel Com", "Mes (Byers)"),
  gene = c("ITGAE", "ZNF683"),
  covariate = "age_at_initial_pathologic_diagnosis",
  isCategoricalCov = FALSE,
  timeCol = "OS.time",
  eventCol = "OS",
  nGroup = 2,
  confInt = F,
  mainTitle1,
  ylabel = "Survival",
  cols = c(brewer.pal(9, "Set1")[c(2, 3, 4, 5, 7, 8)],
           brewer.pal(8, "Dark2")[c(8, 1, 4, 6)]),
  nColLegend = 1,
  plotType = "autoplot") {
  annot[, timeCol] <- gsub("#N/A", NA, annot[, timeCol])
  comSamples <- intersect(rownames(annot), colnames(data))
  data <- data[, comSamples]
  annot <- annot[comSamples, ]
  
  data <- data[, complete.cases(annot[, timeCol])]
  annot <- annot[complete.cases(annot[, timeCol]),]
  
  annot[, timeCol] <- as.numeric(annot[, timeCol] )
  
  ##---------------------------------------- Scores
  if (!is.null(scoreCol)) {
    
    currentscoreCol <- scoreCol[1]
    median_score <- median(annot[, currentscoreCol])
    lowQ_score <- as.numeric(quantile(annot[, currentscoreCol], prob = 0.33))
    upQ_score <- as.numeric(quantile(annot[, currentscoreCol], prob = 0.66))
    
    # annot$scores_2status <-
    #   ifelse(
    #     annot[, currentscoreCol] >= median_score,
    #     paste("High ", currentscoreCol),
    #     paste("Low ", currentscoreCol)
    #   )
    
    annot$scores_2status[annot[, currentscoreCol] >= median_score] <- paste("High ", currentscoreCol)
    annot$scores_2status[annot[, currentscoreCol] < median_score] <- paste("Low ", currentscoreCol)
    
    annot$scores_3status[annot[, currentscoreCol] >= upQ_score] <-
      paste("High ", currentscoreCol)
    annot$scores_3status[annot[, currentscoreCol] <= lowQ_score] <-
      paste("Low ", currentscoreCol)
    annot$scores_3status[annot[, currentscoreCol] < upQ_score &
                           annot[, currentscoreCol] > lowQ_score] <-
      paste("Medium ", currentscoreCol)
    
    
    if (length(scoreCol) == 2) {
      currentscoreCol <- scoreCol[2]
      median_score <- median(annot[, currentscoreCol])
      lowQ_score <-
        quantile(annot[, currentscoreCol], prob = 0.33)
      upQ_score <-
        quantile(annot[, currentscoreCol], prob = 0.66)
      
      annot$scores2_2status <-
        ifelse(
          annot[, currentscoreCol] >= median_score,
          paste("High ", currentscoreCol),
          paste("Low ", currentscoreCol)
        )
      
      annot$scores2_3status[annot[, currentscoreCol] >= upQ_score] <-
        paste("High ", currentscoreCol)
      annot$scores2_3status[annot[, currentscoreCol] <= lowQ_score] <-
        paste("Low ", currentscoreCol)
      annot$scores2_3status[annot[, currentscoreCol] < upQ_score &
                              annot[, currentscoreCol] > lowQ_score] <-
        paste("Medium ", currentscoreCol)
    }
    if (length(scoreCol) > 2) {
      stop(paste0("You must specify maximum of 2 score columns at a time"))
    }
    ## save this new annotation data as sample annotation for the data
    # colData(data) <- newAnnot
  }
  
  ##-------------------------------------- Covariate
  
  if (!is.null(covariate)) {
    annot <- annot[complete.cases(annot[, covariate]), ]
    badcols <-
      c(
        "not reported",
        "NA",
        "Indeterminate",
        "[Not Applicable]",
        "[Not Available]",
        "[Discrepancy]",
        "[Unknown]",
        "Not Evaluable"
      )
    annot <- annot[ ! annot[, covariate] %in% badcols, ]
    
    comSamples <- intersect(row.names(annot), colnames(data))
    annot <- annot[comSamples, ]
    data <- data[, comSamples]
    
    # newAnnot <- colData(data)
    if(isCategoricalCov){
      annot[, covariate] <- as.factor(annot[, covariate])
    }
    else if(! isCategoricalCov) {
      annot[, covariate] <- as.numeric(annot[, covariate])
      median_cov <- median(annot[, covariate], na.rm = T)
      lowQ_cov <-
        as.numeric(quantile(annot[, covariate], prob = 0.33, na.rm = T))
      upQ_cov <-
        as.numeric(quantile(annot[, covariate], prob = 0.66, na.rm = T))
      
      annot$cov_2status <-
        ifelse(annot[, covariate] >= median_cov,
               "High covariate",
               "Low covariate")
      
      annot$cov_3status[annot[, covariate] >= upQ_cov] <-
        "High covariate"
      annot$cov_3status[annot[, covariate] <= lowQ_cov] <-
        "Low covariate"
      annot$cov_3status[annot[, covariate] < upQ_cov &
                          annot[, covariate] > lowQ_cov] <-
        "Medium covariate"
      
    }
  }
  
  currentData <- data
  
  ##------------------------------------- Gene expression
  if (!is.null(gene)) {
    if (sum(rownames(data) %in% gene) < 1) {
      stop(paste0(gene, " does not present in the row names of the expression data"))
    }
    if (length(gene) > 3) {
      stop(paste0("Please provide maximum of 3 genes at a time"))
    }
    currentGene <- gene[1]
    currentGeneIndx <- which(rownames(currentData) == currentGene)
    # newAnnot <- colData(currentData)
    
    ## calculate median and 33%-tile and 66%-tile of gene expression
    median_expr <- median(as.numeric(currentData[ currentGeneIndx, ]))
    lowQ_expr <- as.numeric(quantile(currentData[ currentGeneIndx, ], prob = 0.33))
    upQ_expr <- as.numeric(quantile(currentData[ currentGeneIndx, ], prob = 0.66))
    
    # annot$expr1_2status <-
    #   ifelse(
    #     currentData[ currentGeneIndx, ] >= median_expr,
    #     paste0("High ", currentGene),
    #     paste0("Low ", currentGene)
    #   )
    
    annot$expr1_2status[currentData[ currentGeneIndx, ] >= median_expr] <- paste0("High ", currentGene)
    annot$expr1_2status[currentData[ currentGeneIndx, ] < median_expr] <- paste0("Low ", currentGene)
    
    # annot$expr1_3status[as.numeric(currentData[ currentGeneIndx, ]) >= upQ_expr] <-
    #   paste0("High ", currentGene)
    
    annot$expr1_3status[currentData[ currentGeneIndx, ] >= upQ_expr] <-
      paste0("High ", currentGene)
    
    annot$expr1_3status[currentData[ currentGeneIndx, ] <= lowQ_expr] <-
      paste0("Low ", currentGene)
    annot$expr1_3status[currentData[ currentGeneIndx, ] < upQ_expr &
                          currentData[ currentGeneIndx, ] > lowQ_expr] <-
      paste0("Medium ", currentGene)
    
    ## save this new annotation as sample annotation for the data
    # colData(currentData) <- newAnnot
    
    if (length(gene) > 1) {
      currentGene <- gene[2]
      # newAnnot <- colData(currentData)
      currentGeneIndx <- which(rownames(currentData) == currentGene)
      
      ## calculate median and 33%-tile and 66%-tile of gene expression
      median_expr <-
        median(currentData[currentGeneIndx, ])
      lowQ_expr <-
        as.numeric(quantile(currentData[currentGeneIndx, ], prob = 0.33))
      upQ_expr <-
        as.numeric(quantile(currentData[currentGeneIndx, ], prob = 0.66))
      
      annot$expr2_2status <-
        ifelse(
          currentData[currentGeneIndx, ] >= median_expr,
          paste0("High ", currentGene),
          paste0("Low ", currentGene)
        )
      
      annot$expr2_3status[currentData[currentGeneIndx, ] >= upQ_expr] <-
        paste0("High ", currentGene)
      annot$expr2_3status[currentData[currentGeneIndx, ] <= lowQ_expr] <-
        paste0("Low ", currentGene)
      annot$expr2_3status[currentData[currentGeneIndx, ] < upQ_expr &
                            currentData[currentGeneIndx, ] > lowQ_expr] <-
        paste0("Medium ", currentGene)
      
      if (length(gene) == 3) {
        currentGene <- gene[3]
        currentGeneIndx <- which(rownames(currentData) == currentGene)
        
        ## calculate median and 33%-tile and 66%-tile of gene expression
        median_expr <-
          median(currentData[currentGeneIndx, ])
        lowQ_expr <-
          as.numeric(quantile(currentData[currentGeneIndx, ], prob = 0.33))
        upQ_expr <-
          as.numeric(quantile(currentData[currentGeneIndx, ], prob = 0.66))
        
        annot$expr3_2status <-
          ifelse(
            currentData[currentGeneIndx, ] >= median_expr,
            paste0("High ", currentGene),
            paste0("Low ", currentGene)
          )
        
        annot$expr3_3status[currentData[currentGeneIndx, ] >= upQ_expr] <-
          paste0("High ", currentGene)
        annot$expr3_3status[currentData[currentGeneIndx, ] <= lowQ_expr] <-
          paste0("Low ", currentGene)
        annot$expr3_3status[currentData[currentGeneIndx, ] < upQ_expr &
                              currentData[currentGeneIndx, ] > lowQ_expr] <-
          paste0("Medium ", currentGene)
        
      }
    }
    
    # colData(currentData) <- newAnnot
  }
  
  # currentData <-
  #   currentData[, complete.cases(annot[, timeCol])]
  
  ##------------------------------------- Check for stratification type
  if (stratify == "expr") {
    currentStrata <- paste0("expr1_", nGroup, "status")
    mainTitle <- gene[1]
  }
  if(stratify == "score"){
    currentStrata <- paste0("scores_", nGroup, "status")
    mainTitle <- scoreCol[1]
  }
  if(stratify == "covariate"){
    if(isCategoricalCov){
      currentStrata <- covariate
    }
    else if(!isCategoricalCov){
      currentStrata <- paste0("cov_", nGroup, "status")
    }
    mainTitle <- covariate
  }
  if (stratify == "score_expr") {
    currentSt_score <- paste0("scores_", nGroup, "status")
    currentSt_expr  <- paste0("expr1_", nGroup, "status")
    annot$score_expr <-
      paste0(annot[, currentSt_score],
             " / ",
             annot[, currentSt_expr])
    currentStrata <- "score_expr"
    mainTitle <- paste(scoreCol[1], " &\n", gene[1])
  }
  if (stratify == "covariate_expr") {
    if(is.null(covariate) | is.null(gene)){
      stop("Make sure both covriate and gene are provided")
    }
    
    if(isCategoricalCov){
      currentSt_cov <- covariate
    } else if(!isCategoricalCov){
      currentSt_cov   <- paste0("cov_", nGroup, "status")
    }
    
    #currentSt_cov  <- paste0("cov_", nGroup, "status")
    currentSt_expr <- paste0("expr1_", nGroup, "status")
    ## Remove samples with NA annotation as covariate:
    currentData <- currentData[ , complete.cases(annot[, currentSt_cov])]
    annot$cov_expr <-
      paste0(annot[, currentSt_cov],
             " / ",
             annot[, currentSt_expr])
    currentStrata <- "cov_expr"
    mainTitle <- paste(covariate, " &\n", gene[1])
  }
  if (stratify == "score_covariate") {
    
    if(isCategoricalCov){
      currentSt_cov <- covariate
    } else if(!isCategoricalCov){
      currentSt_cov   <- paste0("cov_", nGroup, "status")
    }
    
    currentSt_score <- paste0("scores_", nGroup, "status")
    
    annot$score_cov <-
      paste0(annot[, currentSt_score],
             " / ",
             annot[, currentSt_cov])
    currentStrata <- "score_cov"
    mainTitle <- paste(scoreCol[1], " &\n", covariate)
  }
  if (stratify == "expr_expr") {
    currentSt_expr1 <- paste0("expr1_", nGroup, "status")
    currentSt_expr2 <- paste0("expr2_", nGroup, "status")
    annot$expr_expr <-
      paste0(annot[, currentSt_expr1],
             " / ",
             annot[, currentSt_expr2])
    currentStrata <- "expr_expr"
    mainTitle <- paste(gene[1], " &\n", gene[2])
  }
  if (stratify == "score_score") {
    currentSt_score1 <- paste0("scores_", nGroup, "status")
    currentSt_score2 <- paste0("scores2_", nGroup, "status")
    annot$score_score <-
      paste0(
        annot[, currentSt_score1],
        " / ",
        annot[, currentSt_score2])
    currentStrata <- "score_score"
    mainTitle <- paste(scoreCol[1], " &\n", scoreCol[2])
  }
  
  if (stratify == "expr_expr_expr") {
    currentSt_expr1 <- paste0("expr1_", nGroup, "status")
    currentSt_expr2 <- paste0("expr2_", nGroup, "status")
    currentSt_expr3 <- paste0("expr3_", nGroup, "status")
    annot$expr_expr_expr <-
      paste0(annot[, currentSt_expr1],
             " / ",
             annot[, currentSt_expr2],
             " / ",
             annot[, currentSt_expr3])
    currentStrata <- "expr_expr_expr"
    mainTitle <- paste(gene[1], " &\n", gene[2], " & ", gene[3])
  }
  ##----------------------------- Fit survival model
  # annot2 <- annot
  # annot2[, timeCol] <- gsub("#N/A", NA, annot2[, timeCol])
  # annot2 <- annot2[complete.cases(annot2[, timeCol]), ]
  tt <- data.frame(table(annot[, currentStrata]))
  tt$Var1 <- as.character(tt$Var1)
  tt$Freq <- as.character(tt$Freq)
  for (i in 1:nrow(tt)) {
    annot$currentStrata_n[annot[, currentStrata] == tt$Var1[i]] <-
      paste0(tt$Var1[i], " (", tt$Freq[i], ")")
  }
  
  annot <- annot[, c("currentStrata_n", timeCol, eventCol)]
  annot[, timeCol] <- as.numeric(annot[, timeCol])
  annot[, eventCol] <- as.numeric(annot[, eventCol])
  
  fitValues <- survfit(Surv(time = annot[, timeCol],
                            event = annot[, eventCol]) ~
                         annot$currentStrata_n)
  
  ss <- survdiff(Surv(time =  annot[, timeCol],
                      event = annot[, eventCol]
  ) ~
    annot$currentStrata_n)
  # 
  #   ss <- survdiff(Surv(annot[, timeCol],
  #                       as.numeric(as.factor(
  #                         annot[, eventCol]
  #                       )) - 1) ~
  #                    annot$currentStrata_n)
  
  ##------------------------------- Calculate p-value
  ## This does not adjust for any covariates, unless the covariate option is included
  
  pval <-  ifelse (is.na(ss), next, (round(1 - pchisq(
    ss$chisq, length(ss$n) - 1
  ), 6)))[[1]]
  
  if(pval < 0.01){
    pval_add <- paste0("p-value (log-rank) < 0.01")
  }
  else{
    pval_add <- paste0("p-value (log-rank) = ", round(pval, 2))
  }
  
  ##------------------------------ Plot survival curve
  if(plotType == "autoplot"){
    p <-  autoplot(fitValues, surv.size = 1.5, conf.int = confInt) +
      scale_color_manual(values = cols) +
      scale_fill_manual(values = cols) +
      ggtitle(paste0(
        mainTitle1, '\n' , 
        # " (Chisq = ", round(ss$chisq, 3),
        #"\n", 
        pval_add)) +
      ylab(ylabel) +
      xlab("Time (days)") +
      theme(
        panel.background = element_blank(),
        legend.position = 'bottom'
        
      ) +
      guides(
        color = guide_legend(ncol = nColLegend), 
        fill = guide_legend(ncol = nColLegend))
    
  }
  else if (plotType == "ggsurvplot"){
    p <- ggsurvplot (
      fitValues,
      data = annot,
      fun = "pct",
      pval = TRUE,
      # pval.method = TRUE,  ## Log Rank
      # test.for.trend = T,  ## when we have more than two groups
      conf.int = confInt,
      surv.median.line = "hv",
      # linetype = "strata",
      palette = cols,
      xlab = "Time",
      legend.title = mainTitle,
      # legend.labs = c("High score", "Low score"),
      legend = c(.2, .2),
      # break.time.by = 4,
      # risk.table = TRUE,
      # tables.height = 0.2,
      # tables.theme = theme_cleantable(),
      # risk.table.y.text.col = TRUE,
      # risk.table.y.text = TRUE
    )
  }
  p_pval <- list(plot = p, pval = pval)
  return(p_pval)
  
}

#=================== Silhouette coefficient =================
# Silhouette coefficient analysis
## pcs is the matrix of principal components
## variable is a categorical variables such sample types
## nPcs is the number of principal components used to measure the distance
.silhouette.coeff <- function(
  pcs, 
  variable, 
  nPCs)
{
  d.matrix <- as.matrix(stats::dist(pcs[, seq_len(nPCs)]))
  summary(cluster::silhouette(
    as.numeric(as.factor(variable)), 
    d.matrix))$avg.width
}

```

```{r setup, include=F}
knitr::opts_chunk$set(
  tidy = FALSE,
  fig.width = 10,
  message = FALSE,
  warning = FALSE)
```

## Introduction

Effective removal of unwanted variation is essential to derive meaningful biological results from RNA-seq data, particularly when the data comes from large and complex studies. We have previously proposed a new method, removing unwanted variation III (RUV-III) to normalize gene expression data [(Molania et al., NAR, 2019)](https://academic.oup.com/nar/article/47/12/6073/5494770?login=true) in Nanostring nCounter gene expression. The RUV-III method requires well-designed technical replicates (well-distributed across sources of unwanted variation) and negative control genes to estimate known and unknown sources of unwanted variation and remove it from the data. We have also applied RUV-III to CyTOF datasets by exploiting pseudo-replicates to estimate the unwanted variation and remove it [(Trussart et al., Elife, 2020)](https://elifesciences.org/articles/59630). It is implemented in the R package [`CytofRUV`](https://github.com/mtrussart/CytofRUV).\
\
We propose a novel strategy, pseudo-replicates of pseudo-samples (PRPS) [(Molania et al., Nature Biotechnology 2022)](https://www.nature.com/articles/s41587-022-01440-w) that uses RUV-III to normalize RNA-seq data in situations when technical replicates are not available or are not well-designed. Our approach requires having defined at least one source of biological variation: a known biologically homogeneous subclass of samples.\

To create PRPS, we first need to identify the sources of unwanted variation, such as the batches and library size. Then to correct for batch variation, we create pseudo-samples where the gene expression measurements of suitable biologically homogeneous sets of samples are averaged within batches. Since the variation between pseudo-samples in different batches is mainly unwanted variation, we can easily and effectively remove the unwanted variation by defining them as pseudo-replicates in RUV-III. We refer to our paper for more technical details [(Molania et al., Nature Biotechnology 2022)](https://www.nature.com/articles/s41587-022-01440-w).\

Here, we provided an example from The Cancer Genome Atlas (TCGA) which is the invasive breast cancer (BRCA) RNA-seq dataset. Our objective is to remove tumour purity, flow cell chemistry, library size and batch effects (plate effects) from the data. By comparing our normalizations to the standard TCGA one, we show how unwanted variation can lead to wrong biological conclusions. Note that RUV-III with PRPS is not limited to TCGA data: it can be used for any large genomics project involving multiple labs, technicians, platforms and so on.\

The TCGA consortium aligned RNA sequencing reads to the hg38 reference genome using the STAR aligner and quantified the results at gene level using the HTseq and Gencode v22 gene-annotation [Ref](https://docs.gdc.cancer.gov/Data/Bioinformatics_Pipelines/Expression_mRNA_Pipeline/).\
The TCGA RNA-seq data are publicly available in three formats: raw counts, FPKM and FPKM with upper-quartile normalization (FPKM.UQ). All these formats for individual cancer types (33 cancer types, ~ 11000 samples) were downloaded using the r Biocpkg("TCGAbiolinks") R/Bioconductor package (version 2.16.1). The TCGA normalized microarray gene expression data were downloaded from the Broad GDAC [Firehose](https://gdac.broadinstitute.org) repository , data version 2016/01/28.\
Tissue source sites (TSS), and batches of sequencing-plates were extracted from individual TCGA [patient barcodes](https://docs.gdc.cancer.gov/Encyclopedia/pages/TCGA_Barcode/), and sample processing times were downloaded from the [MD Anderson Cancer Centre TCGA Batch Effects website](https://bioinformatics.mdanderson.org/public-software/tcga-batch-effects). \
Pathological features of cancer patients were downloaded from the Broad GDAC Firehose repository (https://gdac.broadinstitute.org). The TCGA survival data reported by [Liu et al.](https://www.cell.com/cell/fulltext/S0092-8674(18)30229-0?_returnURL=https%3A%2F%2Flinkinghub.elsevier.com%2Fretrieve%2Fpii%2FS0092867418302290%3Fshowall%3Dtrue) were used in this paper. \
The consensus measurement of purity estimation (CPE) were downloaded from the [Aran et al](https://www.nature.com/articles/ncomms9971) study.\

We have generated SummarizedExperiment objects for all the TCGA RNA-seq datasets. These datasets can be found here [TCGA_PanCancerRNAseq](https://zenodo.org/record/6326542#.YimR0C8Rquo). Unwanted variation of all the datasets can also be explored using an Rshiny application published in [(Molania et al., Nature Biotechnology, 2022)](https://www.nature.com/articles/s41587-022-01440-w).\

### TCGA BRCA gene expression data

We load the TCGA_SummarizedExperiment_HTseq_BRCA.rds file. This is a SummarizedExperiment object that contains:\
**-assays:**\
-Raw counts\
-FPKM\
-FPKM.UQ\
**-colData:**\
-Batch information\
-Clinical information (collected from different resources)\
**-rowData:**\
-Genes' details (GC, chromosome, ...)\
-Several lists of housekeeping genes\

```{r readingRnaSeqData, warning=FALSE, message=FALSE, results=FALSE}
wd="~/Downloads/RUVIIIPRPS_EMR_Workshop/"
brca.se <- readRDS(paste0(wd,'BreastCancer_GeneExpression_TCGARNAseq.rds'))
```

### TCGA microarray data
The TCGA BRCA microarray gene expression data were manually downloaded from the TCGA [firehose](https://gdac.broadinstitute.org) website. The data version 2016_01_28. This data will be used as **orthogonal** platform to assess the performance of different RNA-seq normalizations.

```{r readingMicroArrayData, warning=FALSE, message=FALSE, results=FALSE}
brca.microarray <- readRDS(paste0(wd,'BreastCancer_GeneExpression_TCGAMicroArray.rds'))
```

### Laser capture microdissection gene expression data

In this vignette, we will show how to use RUV-III with PRPS to remove or reduce tumor purity variation from the TCGA RNA-seq data. We use breast cancer laser capture microdissection (LCM) gene expression data to be able to assess the performance of RUV-III-PRPS in terms of removing tumour purity. We are not able to use the TCGA breast cancer microarray gene expression data as this data is being affected by tumor purity as well.\
Here, we load the breast cancer laser capture microdissection gene expression data from the [Toro AL et.al](https://pubmed.ncbi.nlm.nih.gov/27148454/) study.

```{r readingLCMData, warning=FALSE, message=FALSE, results=FALSE}
expr.78958 <- readRDS(paste0(wd,'BreastCancer_GeneExpression_LCM.rds'))
load(paste0(wd,'pam50.rda'))
load(paste0(wd,'pam50.robust.rda'))
```

## Quantification of sources variation

In this section, we will focus on how to identify and quantify all sources of variation present in a dataset. We will first go through the assessments performed for each categorical variable (biology, plates, year...) using several assessment, followed by the assessments for each continuous variable (library size, purity...).\

### Study outline

The BRCA RNA-seq study involved ~1180 assays that were carried out on samples from 40 tissue source sites (TSS), distributed across 38 plates, and profiled over five years from 2010 to 2014 (Figure  \@ref(fig:studyOutline)). The samples collected in 2010 and 2011 were profiled using one flow cell chemistry, and the remaining samples were profiled using a different flow cell chemistry (personal communication from TCGA). There were 94 adjacent normal breast tissue samples and 7 paired primary-metastatic samples in the study.\

```{r studyOutline, warning=F, message=F, error=F, fig.cap='Study outline of the TCGA BRCA RNA-seq data.', fig.topcaption=TRUE}
selected.columns <- c(
  'year_mda',
  'plate_RNAseq',
  'tss_RNAseq',
  'libSize',
  'purity_HTseq_FPKM',
  'Tissue.Type',
  'pam50.geneFu.fpkm',
  'Call',
  'FcCh')
sample.info <- SummarizedExperiment::colData(
  brca.se)[ , selected.columns]
sample.annot <- as.data.frame(colData(x = brca.se))
### Year
years.colors <- c(
  'green',
  'purple4',
  'blue',
  'brown',
  'tan1',
  'darkgreen',
  'black'
)
names(years.colors) <- c(
  '2009',
  '2010',
  '2011',
  '2012',
  '2013',
  '2014',
  '2015'
)
H.year <- ComplexHeatmap::Heatmap(
  rev(sample.info$year_mda),
  cluster_columns  = FALSE,
  column_names_gp = grid::gpar(fontsize = 12),
  col =  years.colors ,
  name = 'Time (years)',
  heatmap_legend_param = list(
    color_bar = "discrete" ,
    ncol = 2,
    title_gp = grid::gpar(fontsize = 12)))
### Plates
n.plate <- length(unique(sample.info$plate_RNAseq)) # 38
colfunc <- grDevices::colorRampPalette(
  RColorBrewer::brewer.pal(11, 'PRGn')[-6])
color.plates <- colfunc(n.plate)
H.plate <- ComplexHeatmap::Heatmap(
  rev(sample.info$plate_RNAseq),
  cluster_rows = FALSE,
  cluster_columns = FALSE,
  column_names_gp = grid::gpar(fontsize = 12),
  col = color.plates,
  name = 'Plates',
  heatmap_legend_param = list(
    color_bar = "discrete" ,
    ncol = 4,
    title_gp = grid::gpar(fontsize = 12)))
### TSS
n.tss <- length(unique(sample.info$tss_RNAseq)) # 40
colfunc <- grDevices::colorRampPalette(
  RColorBrewer::brewer.pal(11, 'BrBG')[-6]
  )
color.tss <- colfunc(n.tss)
H.tss <- ComplexHeatmap::Heatmap(
  rev(sample.info$tss_RNAseq),
  cluster_rows = FALSE,
  cluster_columns = FALSE,
  column_names_gp = grid::gpar(fontsize = 12),
  col = color.tss,
  name = 'Tissue source sites',
  heatmap_legend_param = list(
    color_bar = "discrete" ,
    ncol = 4,
    title_gp = grid::gpar(fontsize = 12)))
### Tissue
H.tissue <- ComplexHeatmap::Heatmap(
  rev(sample.info$Tissue.Type),
  cluster_rows = FALSE,
  column_names_gp = grid::gpar(fontsize = 12),
  col = c("#D9D9D9", 'blue', "#252525"),
  name = 'Tissues',
  heatmap_legend_param = list(
    color_bar = "discrete" ,
    direction = "vertical",
    ncol = 1,
    title_gp = grid::gpar(fontsize = 12),
    labels = c(
      'Primary tumor',
      'Metastatic tumor',
      'Adjacent normal')))
### Purity
H.purity <- ComplexHeatmap::Heatmap(
  rev(sample.info$purity_HTseq_FPKM),
  column_names_gp = grid::gpar(fontsize = 12),
  cluster_rows = FALSE,
  name = 'Tumor purity score',
  col = viridis::plasma(n = 10),
  heatmap_legend_param = list(
    title_gp = grid::gpar(fontsize = 12)))
### library size
H.ls <- ComplexHeatmap::Heatmap(
  rev(sample.info$libSize),
  cluster_rows = FALSE,
  name = 'Library size',
  column_names_gp = grid::gpar(fontsize = 12),
  col = viridis::viridis(n = 10),
   heatmap_legend_param = list(
    title_gp = grid::gpar(fontsize = 12)))
### PAM50
### pam50
pam50.colors <- c(
  'gray',
  'red',
  'darkgreen',
  'navy',
  'cyan3', 
  'darkorange') 
names(pam50.colors) <- c(
  "Adjacent normal", 
  "Basal",
  "Her2",
  "LumA",
  "LumB", 
  "Normal like")
H.pam50.tcga <- ComplexHeatmap::Heatmap(
  rev(sample.info$Call),
  cluster_rows = FALSE,
  name = 'PAM50 (TCGA calls)',
  column_names_gp = grid::gpar(fontsize = 12),
  col = pam50.colors,
   heatmap_legend_param = list(
    title_gp = grid::gpar(fontsize = 12)))
### PAM50 genefu
H.pam50.genefu <- ComplexHeatmap::Heatmap(
  rev(sample.info$pam50.geneFu.fpkm),
  cluster_rows = FALSE,
  name = 'PAM50 (Genefu calls)',
  column_names_gp = grid::gpar(fontsize = 12),
  col = pam50.colors,
   heatmap_legend_param = list(
    title_gp = grid::gpar(fontsize = 12)))
### Flow cell chemistry
FcCh.colors <- c('#440154FF', 'yellow 3')
names(FcCh.colors) <- c(
  '2010:2011', 
  '2012:2014')
H.fcch <- ComplexHeatmap::Heatmap(
  rev(sample.info$FcCh),
  cluster_rows = FALSE,
  name = 'Flow cell chemistry',
  column_names_gp = grid::gpar(fontsize = 12),
  col = FcCh.colors,
   heatmap_legend_param = list(
    title_gp = grid::gpar(fontsize = 12),
    direction = "horizontal"))
ComplexHeatmap::draw(
  H.year +
    H.fcch +
    H.plate +
    H.tss +
    H.tissue +
    H.pam50.tcga +
    H.pam50.genefu +
    H.ls +
    H.purity,
  merge_legends = FALSE,
  heatmap_legend_side = 'right')
```

### PCA plot of the categorical variable

We selected the cancer samples only for the remaining analysis. First we compute principal component analysis (PCA) using the **`compute_pca`** function across all assays in the datasets:\
**-`HTseq-counts`: Raw data counts**\
**-`HTseq-FPKM`: FPKM normalisation** \
**-`HTseq-FPKM.UQ`: FPKM Upper-Quantile normalisation** \
We use the **`plot_pca`** function to plot the PCA colored by a categorical variable. As an example, we show the PCA on the raw data counts colored by the biological `PAM50.geneFu.fpkm` variable (See Figure \@ref(fig:PCAPlotPam50)) .\

```{r PCAPlotPam50,message=FALSE, warning=FALSE, error=FALSE, results=FALSE, fig.dim=c(12,12), fig.cap=' The first three PC coloured by pam50 in the TCGA BRCA raw counts.', fig.topcaption=TRUE}
## Select cancer samples only
index.cancer <- brca.se$tissue == 'cancer'
brca.cancer.se <- brca.se[ , index.cancer]
brca.sampleAnnot.cancer <- as.data.frame(SummarizedExperiment::colData(brca.cancer.se))
brca.fpkmUq.cancer <- SummarizedExperiment::assay(brca.cancer.se,'HTseq_FPKM.UQ')
brca.rawCounts.cancer <- SummarizedExperiment::assay(brca.cancer.se,'HTseq_counts')
### Compute PCA
data_pca=RUVPRPS::compute_pca(brca.cancer.se,apply.log = TRUE)
### PCA plot on PAM50 genefu
cat_var_label='pam50.geneFu.fpkm'
PCA_pam50_raw=RUVPRPS::plot_pca(data_pca,
                      assay_names = "HTseq_counts",
                      cat_var_label = cat_var_label,
                      cat_var=as.factor(brca.sampleAnnot.cancer[ , cat_var_label]),
                      color = pam50.colors)
```

As we mentioned above, the TCGA BRCA RNA-seq samples were profiled over two batches of flow cell chemistries. Comparing PCA plots of the FPKM and FPKM.UQ normalized datasets to the raw data counts, we observed a noticeable variation due to the use of two flow cell chemistries (Figure \@ref(fig:PCAPlotFcCh)).


### Vector correlation between PCs of the gene expression and the categorical variable

We created a function called **`vector_correlation_pc_catvar`** to perform vector correlation between the first PCs cumulatively of the gene expression and a categorical variable representing time, batches, plates, and biological variables.\

Figure \@ref(fig:VCFcCh) shows the vector correlation analysis between the flow cell chemistry batches and the first 10 principal components (cumulatively) for different normalization methods. Ideally, we should see no significant association between the PCs and the batches.

```{r VCFcCh, message=FALSE, warning=FALSE, error=FALSE, results=FALSE, fig.dim=c(12,12), fig.cap='Vector correlation coefficient between the flow cell chemistry and the first 10 cumulative PCs in the TCGA BRCA raw counts, FPKM, FPKM.UQ', fig.topcaption=TRUE}
### Vector correlation
cat_var_label='FcCh'
corr_FcCh=RUVPRPS::vector_correlation_pc_catvar(data_pca,
                                                cat_var_label = cat_var_label,
                                                cat_var=as.factor(brca.sampleAnnot.cancer[ , cat_var_label]),
                                                assay_names=c("HTseq_counts","HTseq_FPKM","HTseq_FPKM.UQ"))
corr_FcCh$plot
```

### Differential analysis based on ANOVA between the gene expression and the categorical variable




We created a function called **`anova_gene_exp_catvar`** which is used to compute the differential analysis between the gene expression and a categorical variable (e.g. batches, biology...) using ANOVA.\

We use ANOVA F-statistics to summarize the effects of a categorical source of unwanted variation (e.g. batches) on the expression levels of individual genes, where genes having large F statistics are deemed to be affected by the unwanted variation.

As an example, we perform ANOVA between individual gene expression and the flow cell chemistry batches across all samples. Figure \@ref(fig:AnovaFcCh) shows log2 F-statistics obtained from the ANOVA analysis. The normalization should reduce the number of genes that are highly affected by the flow cell chemistry batches.

```{r AnovaFcCh, message=FALSE, warning=FALSE, error=FALSE, results=FALSE, fig.dim=c(12,12), fig.cap='Boxplots of log2 F statistics obtained from ANOVA between gene expression and the flow cell chemistry batches.', fig.topcaption=TRUE}
### ANOVA on FcCh
cat_var_label='FcCh'
anova_FcCh=RUVPRPS::anova_gene_exp_catvar(se = brca.cancer.se,
                                     cat_var_label = cat_var_label,
                                     cat_var=as.factor(brca.sampleAnnot.cancer[ , cat_var_label]),
                                     assay_names = c("HTseq_counts","HTseq_FPKM","HTseq_FPKM.UQ"),
                                     apply.log=TRUE)
anova_FcCh$boxplot_ftest
```

### Silhouette and ARI computed on the categorical variable

To assess the separation of biological populations and batch effects, we provided the **`compute_silhouette`** or the **`compute_ari`** functions. 
The **`compute_silhouette`** function uses Euclidean distance to compute the Silhouette coefficient from the first PC given a categorical variable (batch or biology). A successful normalization method should lead to higher silhouette coefficients for biological variable and lower ones for batch labels.\

As an alternative, the **`compute_ari`** can be used to compute the adjusted rank index (ARI) which is the corrected-for-chance version of the Rand Index. The ARI measures the percentage of matches between two label lists. We used the ARI to assess the performance of normalization methods in terms of sample subtypes separation and batch mixing.\

Figure \@ref(fig:SilFcChSilhPam50) shows that the FPKM and FPKM.UQ normalization have higher silhouette coefficients for biological variable but they do not have lower ones from the two flow cell chemistry batches.\

```{r SilFcChSilhPam50, warning=F, message=F, fig.dim=c(12,12), fig.cap='Silhouette coefficients for exhibiting the mixing of samples computed on Pam50 and on two flow cell chemistry batches.', fig.topcaption=TRUE }
### Silhouette computed on Pam50
cat_var_label='pam50.geneFu.fpkm'
silh_Pam50=RUVPRPS::compute_silhouette(pca = data_pca,
                                      assay_names = c("HTseq_counts","HTseq_FPKM","HTseq_FPKM.UQ"),
                                      cat_var_label = cat_var_label,
                                      cat_var=as.factor(brca.sampleAnnot.cancer[ , cat_var_label]))
### Silhouette computed on FcCh
cat_var_label='FcCh'
silh_FcCh=RUVPRPS::compute_silhouette(pca = data_pca,
                                      assay_names = c("HTseq_counts","HTseq_FPKM","HTseq_FPKM.UQ"),
                                      cat_var_label = cat_var_label,
                                      cat_var=as.factor(brca.sampleAnnot.cancer[ , cat_var_label]))


### Combined Silhouette plots computed on FcCh and Pam50
combined_silh_Pam50_FcCh=RUVPRPS::plot_combined_silh(silh_Pam50,silh_FcCh)
combined_silh_Pam50_FcCh
```


### Linear regression between PCs and continuous variable

For continous variables, we use the **`regression_pc_contvar`** function to compute the linear regression between the first cumulative PC and each continuous variable such as sample (log) library size or tumor purity. R2 values of such fitted linear models are used to quantity the strength of the (linear) relationships between a continuous source of unwanted variation and a global sample summary statistics such as the first k PC (1≤k≤10).\

Figure \@ref(fig:LinReglibSize) shows the association between the first 10 PCs and library size in the raw counts and differently normalized data.

```{r LinReglibSize, message=FALSE, warning=FALSE, error=FALSE, results=FALSE, fig.dim=c(12,12), fig.cap='Boxplots of log2 F statistics obtained from ANOVA between gene expression and the flow cell chemistry batches.', fig.topcaption=TRUE}
### Linear regression on Library size
cont_var_label='libSize'
lin_reg_libSize=RUVPRPS::regression_pc_contvar(pca=data_pca,
                                     cont_var_label = cont_var_label,
                                     cont_var=brca.sampleAnnot.cancer[ ,cont_var_label],
                                     assay_names = c("HTseq_counts","HTseq_FPKM","HTseq_FPKM.UQ"))
lin_reg_libSize$plot
```

### Correlation between gene expression and continuous variable

For continous variables, we also use the **`correlation_gene_exp_contvar`** function to perform Spearman correlation between individual gene expression and the categorical variable.
For example, figure \@ref(fig:CorrlibSize) shows the Spearman correlation coefficients between the gene expression levels and the library size across all samples. The FPKM and FPKM.UQ normalization reduced the association between and expression and library size in the TCGA BRCA RNA-Seq data.

```{r CorrlibSize, message=FALSE, warning=FALSE, error=FALSE, results=FALSE, fig.dim=c(12,12), fig.cap='The boxplots of the Spearman correlation coefficients between the individual gene expression levels and library size.', fig.topcaption=TRUE}
### Linear regression on Library size
cont_var_label='libSize'
corr_libSize=RUVPRPS::correlation_gene_exp_contvar(se = brca.cancer.se,
                                     cont_var_label = cont_var_label,
                                     cont_var=brca.sampleAnnot.cancer[ ,cont_var_label],
                                     assay_names = c("HTseq_counts","HTseq_FPKM","HTseq_FPKM.UQ"),
                                     apply.log=TRUE)
corr_libSize$plot
```


### Identification of unwanted variation function

To quantify all the sources of variation, we created a function called **'identify_unwanted_variation'** that exhibits any variation present in samples given the categorical variable (biology, plates, year...) and continuous variable (library size, purity...) provided using all the previous assessments mentioned.\
\
It will output the following plots:\
- PCA plot of each categorical variable.\
- Boxplot of the F-statistics from ANOVA between the gene expression and each categorical variable.\
- Vector correlation between the first cumulative PCs of the gene expression and each categorical variable.\
- Combined Silhouette plot of the combined pair of all categorical variables.\
- Linear regression between the first cumulative PC and continuous variable.\
- Boxplot of the correlation between gene expression and continuous variable.\
- It will also output the RLE plot distribution.\

The user needs to select the data to use ("HTseq_counts","HTseq_FPKM","HTseq_FPKM.UQ") to visualise the diagnostic plots that can be saved into a pdf file which might be advisable for exploratory analysis.\

```{r Variation, message=FALSE, warning=FALSE, error=FALSE,fig.show='hide'}
raw_data_uv=RUVPRPS::identify_unwanted_variation(brca.cancer.se,
                                                assay_names= c("HTseq_counts","HTseq_FPKM","HTseq_FPKM.UQ"),
                                                apply.log = TRUE,
                                                cat_var_label = c('year_mda','PlateId_mda','pam50.geneFu.fpkm','FcCh'),
                                                cont_var_label = c("libSize","purity_HTseq_FPKM"),
                                                output_file=paste0(wd,"Variation_assessment_output.pdf"))

```



## Creation of PRPS


Here, we create the pseudo-replicates of pseudo-samples (PRPS) that will be used to remove unwanted variation from the TCGA BRCA RNA-seq data. Our approach requires having define at least one source of biological variation: a known biologically homogeneous subclass of samples. Here, we use the samples with the consensus PAM50 subtypes (981 samples) to create different sets of PRPS. We create 3 sets of pseudo-replicates of pseudo-samples (PRPS) to remove the tumour purity variation, the library size variation and the flow cell chemistry variation. \

The function **`create_prps`** will create distinct group of pseudo-replicates for each source of unwanted variation. To correct for batchs effect defined in the 'batch' argument, several group of pseudo-samples will be created by averaging the samples of the same biological subtype in each batch. Then those pseudo-samples will be defined as pseudo-replicates.\
To correct for library size defined in the 'librarySize' argument, several group of pseudo-samples will be created by averaging the top and bottom-ranked samples by library size of the same biological subtype in each batch. Then those pseudo-samples will be defined as pseudo-replicates.\
Similarly to correct for tumour purity defined in the 'purity' argument, several group of pseudo-samples will be created by averaging the top and bottom-ranked samples by purity of the same biological subtype in each batch. Then those pseudo-samples will be defined as pseudo-replicates.\

We first select 981 samples that have the same PAM50 subtypes defined by the geneFu classifier applied on the TCGA FPKM and on the FPKM.UQ data respectively.\

```{r CancerSample, warning=F, message=F}
### Select consensus PAM50 calls
cols <- c(
  'pam50.geneFu.fpkm',
  'pam50.geneFu.fpkmUq'
  )
consensus.pam50.calls <- apply(
  brca.sampleAnnot.cancer[ , cols, drop = FALSE],
  1,
  function(x) length(unique(x))
  )
brca.sampleAnnot.cancer$pam50.consensus <- consensus.pam50.calls
samples.to.use <- brca.sampleAnnot.cancer$pam50.consensus == 1 
sum(samples.to.use) #981
```

### Create PRPS function

Using the function **`create_prps`**, we create all these sets of pseudo-samples that will be defined as pseudo-replicates to remove:\
**- flow cell chemistry/plate variation**\
**- library size variation**\
**- tumour purity variation**\
As follow, we will explain in details how we created each PRPS.\

```{r PrPs, message=F, warning=F}
## Create PRPS
prps.brca <-RUVPRPS::create_prps(se = brca.cancer.se[,samples.to.use],
                                 raw_data_assay_label = 'HTseq_counts',
                                 batch = 'PlateId_mda',
                                 biology = 'pam50.geneFu.fpkmUq',
                                 purity = 'purity_HTseq_FPKM',
                                 include.ls = TRUE,
                                 librarySize = "libSize",
                                 minSamplesForLibrarySizePerBatch = 12,
                                 minSamplesForLibrarySizePS = 3,
                                 include.purity = TRUE,
                                 minSamplesForPurityPS = 3,
                                 minSamplesForPurityPerBiology = 12,
                                 minSamplesPerBatchPS = 3)
```



### PRPS to remove flow cell chemistry/plates variation

#### PRPS map 
Figure \@ref(fig:PrPsMapPlates) shows the distribution of the PAM50 subtypes across plates in the data. To create pseudo-samples, we average gene expression of at least 3 samples (red circles) with respect to the biological populations and plates. These sets of pseudo-samples will be defined as pseudo-replicates to remove flow cell chemistry and plate effects.\ 

```{r PrPsMapPlates, message=F, warning=F, fig.dim=c(8,4), fig.cap='Plot showing the sample sizes of the major biological groups across plates in the TCGA BRCA RNA-seq data.'}
ps.sample.info <- droplevels(
  brca.sampleAnnot.cancer[brca.sampleAnnot.cancer$pam50.consensus == 1, ]
  )
new.info <- ps.sample.info
new.info$new.batch <- paste0(
  new.info$year_mda,
  '_',
  new.info$PlateId_mda
  )
new.info$biololy <- paste0(
  new.info$pam50.geneFu.fpkm,
  '_',
  new.info$msi.status)
df_count <- new.info %>%
    dplyr::count(new.batch, biololy)
df_count$use <- 'unselected'
df_count$use[df_count$n > 2] <- 'Selected'
ggplot(df_count, aes(x = new.batch, y = biololy)) +
  geom_count(aes(color = use)) +
  geom_text(aes(
    label = n,
    hjust = 0.5,
    vjust = 0.5
  )) +
  xlab('Years-plates') +
  ylab('Biological groups') +
  theme_bw()+
  theme(
    axis.line = element_line(colour = 'black', size = .85),
    axis.title.x = element_text(size = 18),
    axis.title.y = element_text(size = 0),
    axis.text.x = element_text(size = 10,angle = 45,hjust = 1),
    axis.text.y = element_text(size = 12, angle = 45, hjust = 1),
    legend.position = 'none')
```


#### Library size of PRPS

Figure \@ref(fig:LsOfPrPsPlate) shows the library size of the pseudo-samples of each pseudo-replicate set across plates. As expected, they capture the flow cell chemistry variation that we aim to remove.

```{r LsOfPrPsPlate, warning=FALSE, message=F, error=F, fig.cap='Library size of the PRPS sets for removing flow cell chemistry and plate effects.'}
ps.samples <- base::strsplit(
  x = colnames(prps.brca$ps.batch),
  split = '_'
  )
year <- lapply(
  1:length(ps.samples),
  function(x) {
    index <- which(new.info$plate_RNAseq == ps.samples[[x]][2])
    unique(new.info$year_mda[index])
  })
year.plate <- sapply(
  1:length(ps.samples),
  function(x) paste(
    year[x],
    ps.samples[[x]][2],
    sep = '_'
    )
  )
pam50 <- sapply(
  ps.samples,
  function(x) x[1]
  )
ps <- data.frame(
  bio = pam50,
  year.plate = year.plate,
  ls = log2(colSums(prps.brca$ps.batch))
  )
ggplot(ps, aes(x = year.plate, y = ls))  +
  geom_point(size = 2) +
  geom_line(aes(x = as.numeric(as.factor(year.plate)), y = ls)) +
  xlab('Years_plates') +
  ylab(expression(Log[2]~'library size')) +
  facet_grid(bio ~.) +
  theme(
    axis.text.x = element_text(size = 8, angle = 30, hjust = 1),
    axis.text.y = element_text(size = 8),
    axis.title.x = element_text(size = 14),
    axis.title.y = element_text(size = 14),
    strip.text.y = element_text(size = 12))
```


### PRPS to remove library size per plate

Several group of pseudo-samples will be created by averaging the top and bottom-ranked samples by library size of the same biological subtype in each batch. Then those pseudo-samples will be defined as pseudo-replicates.\

To create PRPS for library size, we selected plates that have at least 12 samples of a particular PAM50 subtypes, and then select the samples with the 3 highest and the 3 lowest values of library size. We then created two pseudo-samples within each PAM50 subtype per plate by averaging the gene expression values across each set.

Figure \@ref(fig:prpsLibSizeLibSize) shows the library size of the pseudo-samples of each pseudo-replicate set across plates.

```{r prpsLibSizeLibSize, fig.cap='Library sizes of pseudo-samples created for removing plate library sizes.'}
### ps for library size
ps.ls.brca <- prps.brca$ps.ls
ps.samples <- base::strsplit(
  x = colnames(ps.ls.brca),
  split = '_'
  )
plates <- sapply(
  ps.samples,
  function(x) x[2]
  )
time.years <- vector()
for(i in 1:length(plates)){
  index <- grep(plates[i], brca.sampleAnnot.cancer$plate_RNAseq)
  year <- unique(brca.sampleAnnot.cancer$year_mda[index])
  time.years <- c(time.years, year)
}
colnames(ps.ls.brca) <- paste(
  colnames(ps.ls.brca),
  time.years,
  sep = '_'
)
samples <- colnames(ps.ls.brca)
samples <- strsplit(
  x = colnames(ps.ls.brca),
  split = '_'
  )
pam50 <- sapply(
  samples,
  function(x) x[1]
  )
year.plate <- sapply(
  samples,
  function(x) paste(x[4], x[2], sep = '_')
  )
ps <- data.frame(
  bio = pam50,
  year.plate = year.plate,
  ls = log2(colSums(ps.ls.brca)))
### plot
ggplot(ps, aes(x = year.plate, y = ls))  +
  geom_point(size = 3) +
  geom_line() +
  xlab('Years_plates') +
  ylim(c(24, 27.5)) +
  ylab(expression(Log[2]~'library size')) +
  facet_grid(bio ~.) +
   theme(
    axis.text.x = element_text(size = 8, angle = 30, hjust = 1),
    axis.text.y = element_text(size = 8),
    axis.title.x = element_text(size = 14),
    axis.title.y = element_text(size = 14),
    strip.text.y = element_text(size = 12))
```

### PRPS to remove tumour purity variation

Several group of pseudo-samples will be created by averaging the top and bottom-ranked samples by purity respectively of the same biological subtype in each batch. Then those pseudo-samples will be defined as pseudo-replicates.\

To remove tumor purity in the TCGA BRCA RNA-seq data, we define sets of PRPS for each PAM50 subtype in addition to those previously created to remove flow cell chemistries and plate to plate variation. We create two pseudo-samples by averaging the gene expression values across the set of the 3 samples with the highest purity values and the set of the 3 samples with the lowest purity values within each PAM50 subtype. Each two sets of pseudo-samples will be defined as pseudo-replicates. These are 5 sets of PRPS (duplicate pseudo-sample pairs).
Figure \@ref(fig:mapPrPsPurity) shows the tumour purity score of those pseudo-samples created to remove tumour purity variation. 

```{r mapPrPsPurity, warning=F, message=F, fig.align='center', fig.dim=c(8,3), fig.cap='Tumour purity scores of pseudo-samples created for removing tumour purity variation.'}
ps.purity.brca <- prps.brca$ps.purity
ps.purity <- lapply(
  levels(brca.sampleAnnot.cancer$pam50.geneFu.fpkm)[2:6],
  function(x){
    info <- brca.sampleAnnot.cancer[brca.sampleAnnot.cancer$pam50.consensus == 1 , ]
    info <- info[info$pam50.geneFu.fpkm == x , ]
    purity <- sort(info$purity_HTseq_FPKM)
    high <- mean(purity[1:3])
    low <- mean(purity[c(c(length(purity)- 2):length(purity)) ])
    all <- c(low, high)
    all
  })
names(ps.purity) <- levels(
  brca.sampleAnnot.cancer$pam50.geneFu.fpkm
  )[2:6]
ps.purity <- as.data.frame(ps.purity)
ps.purity$purity <- c('High', 'Low')
ps.purity <- ps.purity %>%
  tidyr::pivot_longer(
    -purity,
    names_to = 'Pam50',
    values_to = 'Pur') %>%
  data.frame(.)
### Plot
ggplot(ps.purity, aes(x = purity, y = Pur))  +
  geom_point(size = 2) +
  geom_line(aes(x = as.numeric(as.factor(purity)), y = Pur)) +
  xlab('Groups') +
  ylim(c(.22, .7)) +
  ylab('Tumour purity socre') +
  facet_wrap(~Pam50, ncol = 5) +
  theme(
    axis.text.x = element_text(size = 8, hjust = 1),
    axis.text.y = element_text(size = 8),
    axis.title.x = element_text(size = 14),
    axis.title.y = element_text(size = 14),
    strip.text.y = element_text(size = 12))
```


## Selection of negative control genes (NCG)

A negative control gene is one that is not expected to vary across biological factors of interests [(Molania et al., NAR, 2019)](https://academic.oup.com/nar/article/47/12/6073/5494770?login=true). However genes are affected in different ways by the presence of unwanted variation. Therefore our approach to define negative controls is pragmatic, we assess by various measures whether using a given set of negative control genes helps.\
We have shown by theoretical analyses not presented here that it is not the presence of a specific gene in the set of negative controls that drives the success or otherwise of our normalisation but rather the full set of negative controls.\
We have also observed that using more genes as negative control genes is better than using fewer. That is a matter of stability, but as stated in the introduction, there is a bias-variance trade-off here: using too many genes as negative controls may be counter-productive. 
Finally endogenous genes are generally more suitable negative controls than spike-ins, ass spike-ins can only reflect unwanted variation in the process from the point at which they were added onward. The best source of endogenous negative control genes are ones that were found to be stable in previous studies similar to the one being analyzed.\

Here, we selected a suitable set of negative control genes for RUV-PRPS normalization of the TCGA BRCA RNA-seq data as presented in [Molania et al., Nature Biotechnology 2022](https://www.nature.com/articles/s41587-022-01440-w) .\
We first select 981 samples that have the same PAM50 subtypes defined by the geneFu classifier applied on the TCGA FPKM and on the FPKM.UQ data respectively.

```{r NcgDataPrep, warning=F, message=F}
# Keep samples with consensus PAM50 calls
ncg.sample.info <- droplevels(brca.sampleAnnot.cancer[samples.to.use, ])
ncg.sample.info$pam50 <- ncg.sample.info$pam50.geneFu.fpkm
ncg.data <- brca.fpkmUq.cancer[ , samples.to.use]
```

Our selection of negative control genes is focusing on genes whose expression is:\
1) not highly affected by the PAM50 variation (major biological variation)\
2) highly affected by flow cell chemistries\
3) highly correlated with tumour purity\
4) highly correlated with library size.\

### Genes non affected by the PAM50 subtypes

We want to identify genes that are not affected by the biological subtypes, in this case the PAM50 subtypes. Therefore we apply ANOVA on individual genes expression with the PAM50 being a factor within the first batch of flow cell chemistry. The F-statistics are ranked to identify genes that are not highly affected by the PAM50 subtypes.

```{r NcgAnovaPam50, warning=F, message=F, error=F }
n.cores = 5
brca.geneAnnot.ncg <- SummarizedExperiment::rowData(brca.cancer.se)
index.fcch <- ncg.sample.info$FcCh == levels(ncg.sample.info$FcCh)[1]
ftest.pam50.FcCh <- ftest.pam50 <- .Ftest(
      data = ncg.data[ , index.fcch],
      variable = ncg.sample.info$pam50[index.fcch],
      is.log = FALSE,
      n.cores = n.cores
      )
brca.geneAnnot.ncg$pam50.de.2010.11 <- rank(
  ftest.pam50.FcCh$FValue
  )
```

### Genes affected by the flow cell chemistry 

To identify genes that are highly affected by the flow cell chemistry effect, we perform ANOVA on individual genes expression with the flow cell chemistry. The F-statistics are ranked to identify genes that are highly affected by by the flow cell chemistry.

```{r NcgAnovaFcCh, warning=F, message=F}
ftest.FcCh.PerPam50 <- lapply(
  levels(ncg.sample.info$pam50)[1:4],
  function(x){
    index <- ncg.sample.info$pam50.erBalanced.FPKM.UQ == x
    .Ftest(
      data = ncg.data[, index],
      variable = ncg.sample.info$FcCh[index],
      is.log = FALSE,
      n.cores = n.cores
    )
  })
names(ftest.FcCh.PerPam50) <- paste0(
  'FcCh_',
  levels(ncg.sample.info$pam50)[1:4]
  )
for(i in names(ftest.FcCh.PerPam50) ){
  index.na <- is.na(ftest.FcCh.PerPam50[[i]]$FValue)
  ftest.FcCh.PerPam50[[i]]$FValue[index.na] <-
    mean(ftest.FcCh.PerPam50[[i]]$FValue, na.rm = TRUE)
  brca.geneAnnot.ncg[, i] <- rank(-ftest.FcCh.PerPam50[[i]]$FValue)
}
```

### Genes affected by tumour purity

To identify genes that are correlated with tumour purity, we perform Spearman correlation analysis between individual gene expression and tumor purity variation within each PAM50 subtypes. This analysis helps us to identify genes that are affected by tumor purity.

```{r NcgCorrGenesPurity, warning=F, message=F}
ncg.sample.info$fch.pam50 <- paste(
  ncg.sample.info$pam50,
  ncg.sample.info$FcCh,
  sep = '_'
  )
corr.gene.purity.per.pam50.fcch <- lapply(
  unique(ncg.sample.info$fch.pam50)[1:4],
  function(x){
    index <- ncg.sample.info$fch.pam50 == x
    .corr.gene.variable(
      expr.data  = ncg.data[, index],
      variable  = ncg.sample.info$purity_HTseq_FPKM[index],
      is.log = FALSE,
      method = 'spearman',
      n.cores = n.cores,
      group = 'purity'
    )
  })
names(corr.gene.purity.per.pam50.fcch) <- paste0(
  'PurityCorr_',
  unique(ncg.sample.info$fch.pam50)[1:4]
  )
for(i in names(corr.gene.purity.per.pam50.fcch) ){
  index.na <- is.na(corr.gene.purity.per.pam50.fcch[[i]]$purity_rho)
  corr.gene.purity.per.pam50.fcch[[i]]$purity_rho[index.na] <-
      mean(corr.gene.purity.per.pam50.fcch[[i]]$purity_rho, na.rm = TRUE)
  brca.geneAnnot.ncg[, i] <- abs(corr.gene.purity.per.pam50.fcch[[i]]$purity_rho)
}
```

### Genes affected by library size

Finally, we perform Spearman correlation analysis between individual gene expression and library size to identify genes that are affected by library size. This analysis helps us to identify genes that are affected by library size.

```{r NcgCorrGenesLs, warning=F, message=F}
corr.gene.ls.ncg <- .corr.gene.variable(
      expr.data  = brca.rawCounts.cancer,
      variable  = brca.sampleAnnot.cancer$libSize,
      is.log = FALSE,
      method = 'spearman',
      n.cores = n.cores,
      group = 'purity'
    )
brca.geneAnnot.ncg$corr.ls <- corr.gene.ls.ncg$purity_rho
```

### Final selection of NCG

Altogether we have selected genes which\
**1) are not highly affected by the PAM50 variation**\
**2) are highly affected by flow cell chemistries**\
**3) are highly correlated with tumour purity**\
**4) are highly correlated with library size**\ 
We use different cut-offs to selected different sets of NCGs and assessed the performance.\

```{r AllNcgSets, warning=F, message=F}
### FsCh
purity.corr <- .7
ls.corr <- .7
nGenes <- 10000
ncg.set.FsCh <-  brca.geneAnnot.ncg$pam50.de.2010.11 < nGenes &
      brca.geneAnnot.ncg$FcCh_Her2 < nGenes &
      brca.geneAnnot.ncg$FcCh_Basal < nGenes &
      brca.geneAnnot.ncg$FcCh_LumA < nGenes &
      brca.geneAnnot.ncg$FcCh_LumB < nGenes


ncg.set.purity <-  brca.geneAnnot.ncg$pam50.de.2010.11 < nGenes &
      brca.geneAnnot.ncg$`PurityCorr_LumB_2010:2011` > purity.corr &
      brca.geneAnnot.ncg$`PurityCorr_LumA_2010:2011` > purity.corr &
      brca.geneAnnot.ncg$`PurityCorr_Her2_2010:2011` > purity.corr &
      brca.geneAnnot.ncg$`PurityCorr_Basal_2010:2011` > purity.corr

ncg.set.ls <-  brca.geneAnnot.ncg$pam50.de.2010.11 < nGenes &
      brca.geneAnnot.ncg$corr.ls > ls.corr
all.ncg.sets <- c(
      brca.geneAnnot.ncg$gene_name.[ncg.set.ls],
      brca.geneAnnot.ncg$gene_name.[ncg.set.purity],
      brca.geneAnnot.ncg$gene_name.[ncg.set.FsCh])
length(all.ncg.sets) # 4514
```

### Assessments of negative control genes

We perform PCA on the raw counts of the TCGA BRCA RNA-seq data using only the selected NCG to assess their performance. Ideally, they should capture tumor purity variation, flow cell chemistry and library size effects. Note that, the RUV-III method is robust to negative control genes, but not always.\
Figure \@ref(fig:PcaOnNcg) shows the first three PCs on the selected NCG in the raw counts of the TCGA BRCA RNA-seq data. We do not see the PAM50 clusters, but we do see the flow cell chemistry effects.


```{r PcaOnNcg, warning=F, message=F, fig.dim=c(11,6), fig.cap='PCA plots of the raw counts of the TCGA BRCA RNA-seq data using only the negative control genes (4514 genes).'}
# all.ncg.sets <- readRDS('../Vig_all.ncg.sets.rds')
pca.ncg <- .pca(
  data = brca.rawCounts.cancer[
  all.ncg.sets , ],
  is.log = FALSE
  )
cols <- c(
  'pam50.geneFu.fpkm',
  'FcCh'
)
pam50.colors.b <- pam50.colors[2:6]
name.cols <- c(
  'PAM50',
  'Flow cell chemistry'
  )
colors <- c(
  'pam50.colors.b',
  'FcCh.colors'
  )
pp <- lapply(
  c(1:2),
  function(x){
    p <- .scatter.density.pc(
      pcs = pca.ncg$sing.val$u[, 1:3],
      pc.var = pca.ncg$variation,
      group.name = name.cols[x],
      group = brca.sampleAnnot.cancer[ , cols[x]],
      color = base::get(colors[x]),
      strokeSize = .2,
      pointSize = 2,
      strokeColor = 'gray30',
      alpha = .6,
      title = 'Negative control genes'
    )
    p
  })
do.call(
  gridExtra::grid.arrange,
  c(pp[[1]],
    pp[[2]],
    ncol = 4))
```

Further, Figure \@ref(fig:NcgLsPurity) shows the relationship between the first and third PCs of the negative control genes with library size and tumour purity scores. These results show that the NCG are suitable for RUV-III normalization.

```{r NcgLsPurity, warning=F, message=F, fig.dim=c(7,3), fig.cap='Scatter plots show relationship between the first and third PCs of the negative control genes with library size and tumour purity scores'}
df <- data.frame(
  pc1 = pca.ncg$sing.val$u[,1],
  pc3 = pca.ncg$sing.val$u[,3],
  LibSize = brca.cancer.se$libSize,
  purity = brca.cancer.se$purity_HTseq_FPKM.UQ)

p1 <- ggplot(df, aes(x = LibSize, y = pc1)) +
  geom_point(color = 'grey40', alpha = .5) +
  xlab(expression(Log[2]~'library size')) +
  ylab('PC1') +
  theme(
    panel.background = element_blank(),
    axis.line = element_line(colour = 'black', size = 1),
    axis.title.x = element_text(size = 14),
    axis.title.y = element_text(size = 14),
    axis.text.x = element_text(size = 10),
    axis.text.y = element_text(size = 10))

p2 <- ggplot(df, aes(x = purity, y = pc3)) +
  geom_point(color = 'grey40', alpha = .5) +
  xlab('Tumour purity scores') +
  ylab('PC3') +
  theme(
    panel.background = element_blank(),
    axis.line = element_line(colour = 'black', size = 1),
    axis.title.x = element_text(size = 14),
    axis.title.y = element_text(size = 14),
    axis.text.x = element_text(size = 10),
    axis.text.y = element_text(size = 10)
  )
gridExtra::grid.arrange(
  p1,
  p2,
  ncol = 2)
```


# RUV-PRPS normalization

Here, we apply the RUV-III normalization with the different sets of PRPS and selected negative control genes. We refer to [Molania et al., Nature Biotechnology 2022](https://www.nature.com/articles/s41587-022-01440-w), and [(Molania et al., NAR, 2019)](https://academic.oup.com/nar/article/47/12/6073/5494770?login=true) for more details about the RUV-III method.

The **'ruv_III_prps'** function allows the user to adjust for batch effects with parameter settings for the RUV-PRPS algorithm, such as the negative control genes to use and the value of k. 

```{r RuviiiNorm, message=FALSE, warning=FALSE}
## Prepare the input data for the normalisation
colnames(prps.brca$ps.batch) <-  unlist(lapply(
  colnames(prps.brca$ps.batch),
  function(x){
    unlist(strsplit(x, '[_]'))[1]
  }))
brca.ruv.input <- t(log2(cbind(
  brca.rawCounts.cancer,
  prps.brca$ps.ls,
  prps.brca$ps.batch,
  prps.brca$ps.purity
  ) + 1)) # 1252 16537

## Get the replicate matrix
rep.matrix.ruv <- ruv::replicate.matrix(row.names(brca.ruv.input)) 
dim(rep.matrix.ruv)# 1252 1119

## Get the negative control genes
negative.control.genes <- colnames(brca.ruv.input) %in% all.ncg.sets
sum(negative.control.genes) #4163

## Run the RUVIII-PRPS normalization
ruviii.norm  <- RUVPRPS::ruv_III_prps(
  Y = brca.ruv.input,
  M = rep.matrix.ruv,
  ctl = negative.control.genes,
  k = 12,
  eta = NULL,
  return.info = TRUE)
ruviii.prps.norm <- t(ruviii.norm$newY[1:ncol(brca.cancer.se), ])
dim(ruviii.prps.norm) #16537 1086
```

### PAM50 subtypes
We need to identify major gene expression-based biological populations in order to create pseudo-samples and assess the performance of different normalization methods in the separation of these subtypes. As we have mentioned above, the PAM50 subtypes are well-known in the breast cancer gene expression data. \
Here, we adopt different approaches to identify the PAM50 subtypes in the TCGA RNA-Seq data. We use the genefu R package to identify the PAM50 subtypes in the RUV-III normalized data.

```{r geneFuPam50Ruv, warning=F, message=F}
pam50.ruv <- .pam50.geneFu(expr.data = ruviii.prps.norm,
                            gene.annot = as.data.frame(SummarizedExperiment::rowData(brca.se)))
index.cancer <- which(brca.se$tissue == 'cancer')
brca.se$pam50Genefu.ruv <- 'Adjacent normal'
brca.se$pam50Genefu.ruv[index.cancer] <- as.character(pam50.ruv$subtype)
brca.se$pam50Genefu.ruv[brca.se$pam50Genefu.ruv == 'Normal'] <- 'Normal like'
brca.se$pam50Genefu.ruv <- factor(
  brca.se$pam50Genefu.ruv,
  levels = c(
    'Basal',
    'Her2',
    'LumA',
    'LumB',
    'Normal like'))
```

## Normalization performance assessments

We perform a range of statistical tests on the TCGA raw counts, FPKM , FPKM.UQ and RUV-III normalized datasets. These statistical tests are divided into gene and global-level analyses. We create a new SummarizedExperiment object with all the datasets.

```{r seObj, message=F, error=F, warning=F}
brca.cancer.se <- SummarizedExperiment::SummarizedExperiment(
  assays = list(
    HTseq_counts = log2(SummarizedExperiment::assay(
      brca.se[ , index.cancer],
      'HTseq_counts') + 1),
    HTseq_FPKM = log2(SummarizedExperiment::assay(
      brca.se[ , index.cancer],
      'HTseq_FPKM') + 1),
    HTseq_FPKM.UQ = log2(SummarizedExperiment::assay(
      brca.se[ , index.cancer],
      'HTseq_FPKM.UQ') + 1),
    RUV_III = ruviii.prps.norm
    ),
  colData = droplevels(S4Vectors::DataFrame(
    SummarizedExperiment::colData(brca.se[ , index.cancer]))),
  rowData = as.data.frame(
    SummarizedExperiment::rowData(brca.se))
  )
normalizations <- names(
  SummarizedExperiment::assays(brca.cancer.se)
  )
normalizations.names <- c(
  'Raw counts', 
  'FPKM', 
  'FPKM.UQ', 
  'RUV-III')
pam50.levels <- levels(
  brca.cancer.se$pam50.geneFu.fpkmUq)
genefu.calls <- c(
  'pam50.geneFu.raw',
  'pam50.geneFu.fpkm',
  'pam50.geneFu.fpkmUq',
  'pam50Genefu.ruv')
```



Here, we perform principal component analysis (PCA) across all samples for the individual datasets.\

```{r PcaAllSamples, warning=F, message=F}
### Compute PCA
data_pca_all=RUVPRPS::compute_pca(brca.cancer.se,apply.log = FALSE)
```


### Library size effects

#### Linear regression between PCs and library size

As we have seen previously Figure \@ref(fig:lregLs) shows the association between the first 10 PC and library size in the raw counts and differently in the normalized data with RUVIII normalised datasets having the lowest values across all PCs.

```{r lregLs, warning=F, message=F, fig.cap='A plot showing the R-squared of linear regression between library size and up to the first 10 principal components (taken cumulatively) for different normalization methods.'}

### Linear regression on Library size
cont_var_label='libSize'
lin_reg_libSize=RUVPRPS::regression_pc_contvar(pca=data_pca_all,
                                     cont_var_label = cont_var_label,
                                     cont_var=brca.sampleAnnot.cancer[ ,cont_var_label])
lin_reg_libSize$plot
```

#### Correlations between gene expression and library size

As previously, we performed Spearman correlation between individual gene expression and library size across all samples and all normalised datasets.

```{r corrGeneLsLib, warning=F, message=F, fig.dim=c(8,4), fig.cap='The boxplots of the Spearman correlation coefficients between the individual gene expression levels and library size within the PAM50 subtypes in differently normalized datasets'}

cont_var_label='libSize'
corr_libSize=RUVPRPS::correlation_gene_exp_contvar(se = brca.cancer.se,
                                     cont_var_label = cont_var_label,
                                     cont_var=brca.sampleAnnot.cancer[ ,cont_var_label],
                                     apply.log=FALSE)
corr_libSize$plot
```

### Flow cell chemistry effects

#### PCA plots

As we mentioned above, the TCGA BRCA RNA-seq samples were profiled over two batches of flow cell chemistries. PCA plots of the FPKM and FPKM.UQ normalized datasets showed noticeable variation due to the use of two flow cell chemistries whereas RUV-III effectively removed this variation from the data (Figure \@ref(fig:pcaPlotsFcCh)).

```{r pcaPlotsFcCh, message=FALSE, warning=FALSE, error=FALSE, results=FALSE, fig.dim=c(12,12), fig.cap=' The first three PC coloured by flow cell chemistry in the TCGA BRCA raw counts, FPKM, FPKM.UQ and RUV-III normalized data.'}
### PCA plot on PAM50 genefu
cat_var_label='FcCh'
PCA_all_FcCh=RUVPRPS::plot_pca(data_pca_all,
                      cat_var_label = cat_var_label,
                      cat_var=as.factor(brca.sampleAnnot.cancer[ , cat_var_label]),
                      color = FcCh.colors)
```

#### Vector correlation between PCs and flow cell chemistry

Figure \@ref(fig:ccaFch) shows the vector correlation analysis between the flow cell chemistry batches and the first 10 cumlatives PC for different normalization methods. Ideally, we should see no significant association between the PCs and the batches.

```{r ccaFch, message=FALSE, warning=FALSE, fig.cap='A plot showing the vector correlation coefficient between the flow cell chemistry and up to the first 10 principal components.'}
### Vector correlation
cat_var_label='FcCh'
corr_FcCh=RUVPRPS::vector_correlation_pc_catvar(data_pca_all,
                                                cat_var_label = cat_var_label,
                                                cat_var=as.factor(brca.sampleAnnot.cancer[ , cat_var_label]),)
corr_FcCh$plot
```

####  Differential analysis based on ANOVA between the gene expression and the flow cell chemistry

Figure \@ref(fig:anovaFcCh) shows log2 F-statistics obtained from ANOVA analysis. The RUV-III normalization reduced the number of genes that are highly affected by the flow cell chemistry batches.

```{r anovaFcCh, warning=F, message=F, error=F, fig.dim=c(6,3), fig.cap='Boxplots of log2 F statistics obtained from ANOVA for gene expression with flow cell chemistry batche as a factor.'}
### ANOVA on FcCh
cat_var_label='FcCh'
anova_FcCh=RUVPRPS::anova_gene_exp_catvar(se = brca.cancer.se,
                                     cat_var_label = cat_var_label,
                                     cat_var=as.factor(brca.sampleAnnot.cancer[ , cat_var_label]),
                                     apply.log=FALSE)
anova_FcCh$boxplot_ftest
```

#### Silhouette coefficient computed on flow cell chemistry and Pam50 subtypes

Figure \@ref(fig:silAriCoefFcCh) shows that the RUV-III normalization outperforms the other normalization in mixing samples from the two flow cell chemistry batches.\

```{r silAriCoefFcCh, warning=F, message=F, fig.dim=c(8,4), fig.cap='Silhouette coefficients and ARI index for exhibiting the mixing of samples from two  flow cell chemistry batches.'}
### Silhouette computed on Pam50
cat_var_label='pam50.geneFu.fpkm'
silh_Pam50=RUVPRPS::compute_silhouette(pca = data_pca_all,
                                      cat_var_label = cat_var_label,
                                      cat_var=as.factor(brca.sampleAnnot.cancer[ , cat_var_label]))
### Silhouette computed on FcCh
cat_var_label='FcCh'
silh_FcCh=RUVPRPS::compute_silhouette(pca = data_pca_all,
                                      cat_var_label = cat_var_label,
                                      cat_var=as.factor(brca.sampleAnnot.cancer[ , cat_var_label]))


### Combined Silhouette plots computed on FcCh and Pam50
combined_silh_Pam50_FcCh=RUVPRPS::plot_combined_silh(silh_Pam50,silh_FcCh)
combined_silh_Pam50_FcCh
```

### Tumour purity

Tumor purity is one of the major sources of variation in the BRCA study as in other TCGA RNA-seq studies. For this dataset, we designed our PRPS in order to remove the effects of tumor purity as well as other technical variation.

#### Linear regression between PCs and tumour purity

Figure \@ref(fig:LregPurityAll) shows that the RUV-III normalization mitigate the tumor purity variation in the TCGA BRCA RNA-seq data. The FPKM and FPKM.UQ normalization method are not designed to remove tumor purity variation from cancer gene expression data.

```{r LregPurityAll, message=FALSE, warning=FALSE, fig.cap='A plot showing the R-squared of linear regression between tumour purity and up to the first 10 principal components (taken cumulatively) for different normalization methods.'}
### Linear regression on Tumour purity
cont_var_label='purity_HTseq_FPKM.UQ'
lin_reg_purity=RUVPRPS::regression_pc_contvar(pca=data_pca_all,
                                     cont_var_label = cont_var_label,
                                     cont_var=brca.sampleAnnot.cancer[ ,cont_var_label])
lin_reg_purity$plot
```

#### Correlations between gene expression and tumour purity
Figure 7.3 shows Spearman correlation coefficients between the gene expression levels and tumor purity within each PAM50 subtype in differently normalized data. The RUV-III normalization reduced the association between and expression and purity in the TCGA BRCA RNA-Seq data.

```{r PurityCorrGenes, message=FALSE, warning=FALSE, fig.dim=c(12, 6), fig.cap='Boxplots of Spearman correlation coefficients between the gene expression levels and tumour purity within each PAM50 subtypes in differently normalized data.'}
cont_var_label='purity_HTseq_FPKM.UQ'
corr_purity=RUVPRPS::correlation_gene_exp_contvar(se = brca.cancer.se,
                                     cont_var_label = cont_var_label,
                                     cont_var=brca.sampleAnnot.cancer[ ,cont_var_label],
                                     apply.log=FALSE)
corr_purity$plot
```


### Normalisation assessment function

We created a function called **'norm_assessment'** that is used to assess the performance of all the normalisations given the categorical variable (biology, plates, year...) and continuous variable (library size, purity...) provided using all the previous assessments mentioned.\
\
It will output the following plots:\
- PCA plot of each categorical variable.\
- Boxplot of the F-test distribution from ANOVA between the gene expression and each categorical variable.\
- Vector correlation between the first few PCs of the gene expression cumulatively and each categorical variable.\
- Combined Silhouette plot of the combined pair of all categorical variables.\
- Linear regression between the first cumulative PC and continuous variable.\
- Boxplot of the correlation between gene expression and continuous variable.\
- It will also output the RLE plot distribution.\

The user can saved all the assessments into a pdf file to visualise the diagnostic plots which might be advisable for exploratory analysis.\

```{r NormAss, message=FALSE, warning=FALSE, error=FALSE,fig.show='hide'}
norm_ass=RUVPRPS::norm_assessment(brca.cancer.se,
                                  apply.log = FALSE,
                                  cat_var_label = c('year_mda','PlateId_mda','pam50.geneFu.fpkm'),
                                  cont_var_label = c("libSize","purity_HTseq_FPKM"),
                                  output_file=paste0(wd,"All_Norm_assessment_output.pdf"))

```



# R session
```{r}
options(max.print = 10^4)
sessionInfo()
```


