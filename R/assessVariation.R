#' Assess the variation of biological and unwanted variables.

#' @author Ramyar Molania

#' @description
#' This function applies a range of global and gene level metrics to assess the variation in biological and unwanted
#' variables.

#' @details
#' Several assessment will be performed:
#' For each categorical variable:
#' - PCA plot of the categorical variable.
#' - Silhouette and ARI computed on the categorical variable.
#' - Differential analysis based ANOVA between the gene expression and the categorical variable.
#' - Vector correlation between the first cumulative PCs of the gene expression and the categorical variable.
#' For each continous variable:
#' - Linear regression between the first cumulative PC and continuous variable.
#' - Correlation between gene expression and continuous variable.
#'
#' It will output the following plots:
#' - PCA plot of each categorical variable.
#' - Boxplot of the F-test distribution from ANOVA between the gene expression and each categorical variable.
#' - Vector correlation between the first cumulative PCs of the gene expression and each categorical variable.
#' - Combined Silhouette plot of the combined pair of all categorical variables.
#' - Linear regression between the first cumulative PC and continuous variable.
#' - Boxplot of the correlation between gene expression and continuous variable.
#' - It will also output the RLE plot distribution.

#' @references
#' Molania R., ..., Speed, T. P., A new normalization for Nanostring nCounter gene expression data, Nucleic Acids Research,
#' 2019.
#' Molania R., ..., Speed, T. P., Removing unwanted variation from large-scale RNA sequencing data with PRPS,
#' Nature Biotechnology, 2023


#' @param se.obj A SummarizedExperiment object that will be used to compute the PCA.
#' @param assay.names Symbol. A symbol or a vector of symbols for the selection of the name(s) of the assay(s) of the
#' SummarizedExperiment class object. By default all the assays of the SummarizedExperiment class object will be selected.
#' @param variables String or vector of strings of the label of continuous or categorical variable(s)
#' such as samples types, batch or library size from colData(se).
#' @param metrics Symbol. A symbol or vector of symbols indication winch assessment metrics to use.
#' @param metrics.to.exclude A symbol or vector of symbols indication winch assessment metrics to be excluded.
#' @param rle.iqr.width Numeric. Indicates the width of the RLE IQR width. The default is 1.
#' @param rle.plot.ncol Numeric. Indicates the columns of the plot grid in the RLE plot. The default is 1.
#' @param rle.median.points.size Numeric. Indicates the size of the points of the RLE medians. The default is 1.
#' @param rle.geom.hline.color Symbol. Indicates a color of the horizontal line in the RLE plot.
#' @param fast.pca Logical. Indicates whether to calculate a specific number of PCs instead of the full range
#' to speed up the process, by default is set to 'TRUE'.
#' @param compute.nb.pcs Numeric. The number of first PCs to be calculated for the fast pca process, by default is set to 10.
#' @param center.pca Logical. Indicates whether to scale the data or not before applying SVD. If center is TRUE, then centering is done by
#' subtracting the column means of the assay from their corresponding columns. The default is TRUE.
#' @param scale.pca Logical. Indicates whether to scale the data or not before applying SVD.  If scale is TRUE, then scaling
#' is done by dividing the (centered) columns of the assays by their standard deviations if center is TRUE, and the root
#' mean square otherwise. The default is FALSE.
#' @param svd.bsparam A BiocParallelParam object specifying how parallelization should be performed. The default is bsparam().
#' We refer to the 'runSVD' function from the BiocSingular R package.
#' @param nb.pcs.toplot.pca Numeric. Indicates the number of PCs to plotted against each other.
#' @param apply.log Logical. Indicates whether to apply a log-transformation to the data. By default
#' no transformation will be selected.
#' @param pseudo.count Numeric. A value as a pseudo count to be added to all measurements before log transformation,
#' by default it is set to 1.
#' @param general.points.size Numeric. The size of points in all the scatter plots generated by the functions.
#' @param sil.dist.measure A character string indicating which method
#' is to be used for the differential analysis: 'euclidean', 'maximum', 'manhattan', 'canberra', 'binary' or 'minkowski'.
#' By default 'euclidean' will be selected.
#' @param sil.nb.pcs Numeric. Indicates the number of PCs that should be used to compute the silhouette coefficients.
#' @param ari.clustering.method Symbol. Indicates which clustering methods should be applied on the PCs calculate the ARI.
#' The function provides the 'mclust' or 'hclust' methods. The default is 'hclust'.
#' @param ari.hclust.method Symbol. Indicate the agglomeration method to be used for the 'hclust' method. This should be
#' one of 'ward.D', 'ward.D2', 'single', 'complete', 'average' (= UPGMA), 'mcquitty' (= WPGMA), 'median' (= WPGMC) or
#' 'centroid' (= UPGMC). See the hclust function for more details.
#' @param ari.hclust.dist.measure Symbol. Indicates the distance measure to be used in the dist function. This must be
#' one of euclidean', 'maximum', 'manhattan', 'canberra', 'binary' or 'minkowski'. See the dist function for more details.
#' @param ari.nb.pcs Numeric. Indicates the number of PCs that should be used to compute the ARI.
#' @param corr.method Symbol. Indicates which correlation methods should be used. Options are The default is 'spearman'.
#' @param anove.method Symbol. Indicates which ANOVA methods should be used. Options are ... . The default is 'aov'.
#' @param assess.se.obj Logical. Indicates whether to assess the SummarizedExperiment class object.
#' @param remove.na Symbol. To remove NA or missing values from the assays or not. The options are 'assays' and 'none'.
#' The default is "assays", so all the NA or missing values from the assay(s) will be removed before computing RLE. See
#' the checkSeObj function for more details.
#' @param output.file Path and name of the output file to save the assessments plots in a pdf format.
#' @param verbose Logical. If TRUE, displaying process messages is enabled.

#' @return A SummarizedExperiment object containing all the assessments plots and metrics. If specified it will generate
#' a pdf containing the assessments plots and metrics used for the assessment.

#' @importFrom SummarizedExperiment assays colData
#' @importFrom RColorBrewer brewer.pal
#' @importFrom kunstomverse geom_boxplot2
#' @importFrom grDevices colorRampPalette dev.off pdf
#' @importFrom gridExtra grid.arrange grid.table
#' @importFrom graphics plot.new text
#' @export

assessVariation <- function(
        se.obj,
        assay.names = 'all',
        variables,
        metrics = 'all',
        metrics.to.exclude = NULL,
        rle.iqr.width = 2,
        rle.plot.ncol = 1,
        rle.median.points.size = 1,
        rle.geom.hline.color = "cyan",
        fast.pca = TRUE,
        compute.nb.pcs = 10,
        center.pca = TRUE,
        scale.pca = FALSE,
        svd.bsparam = bsparam(),
        nb.pcs.toplot.pca = 3,
        apply.log = TRUE,
        pseudo.count = 1,
        general.points.size = 1,
        sil.dist.measure = 'euclidian',
        sil.nb.pcs = 3,
        ari.clustering.method = "hclust",
        ari.hclust.method = "complete",
        ari.hclust.dist.measure = "euclidian",
        ari.nb.pcs = 3,
        corr.method = 'spearman',
        anove.method = 'aov',
        assess.se.obj = TRUE,
        remove.na = 'both',
        output.file = NULL,
        verbose = TRUE
){
    printColoredMessage(message = '------------The assessVariation function starts:',
                        color = 'white',
                        verbose = verbose)
    # check the inputs of PCA ####
    if (length(assay.names) == 1 && assay.names != 'all') {
        if (!assay.names %in% names(assays(se.obj)))
            stop('The "assay.name" cannot be found in the SummarizedExperiment object.')
    }
    if (length(assay.names) > 1) {
        if (length(setdiff(assay.names, names(assays(se.obj)))) > 0)
            stop('The assay names cannot be found in the SummarizedExperiment object.')
    }
    if (fast.pca & is.null(compute.nb.pcs)) {
        stop('To perform fast PCA, the number of PCs (compute.nb.pcs) must specified.')
    } else if (fast.pca & compute.nb.pcs == 0) {
        stop('To perform fast PCA, the number of PCs (compute.nb.pcs) must specified.')
    }

    # assays ####
    if (length(assay.names) == 1 && assay.names == 'all') {
        assay.names <- as.factor(names(assays(se.obj)))
    } else assay.names <- factor(x = assay.names, levels = assay.names)
    if(!sum(assay.names %in% names(assays(se.obj))) == length(assay.names)){
        stop('The "assay.names" cannot be found in the SummarizedExperiment object.')
    }

    # assess the SummarizedExperiment object ####
    if (assess.se.obj) {
        se.obj <- checkSeObj(
            se.obj = se.obj,
            assay.names = assay.names,
            variables = NULL,
            remove.na = 'measurements',
            verbose = verbose
        )
    }

    # find categorical and continuous variables ####
    categorical.vars <- continuous.vars <- NULL
    if (!is.null(variables)) {
        vars.class <- sapply(
            variables,
            function(x) class(colData(se.obj)[[x]]))
        categorical.vars <- names(vars.class[vars.class %in% c('character', 'factor')])
        continuous.vars <- names(vars.class[vars.class %in% c('numeric', 'integer')])
    }

    # all possible metrics for each variable #####
    printColoredMessage(
        message = 'Find all possible assessment metrics:',
        color = 'magenta',
        verbose = verbose)
    all.metrics <- getAssessmentMetrics(
        se.obj = se.obj,
        variables = variables)
    printColoredMessage(
        message = paste0(
            length(all.metrics$final.metrics.list),
            ' assessment plots will be generated.'),
        color = 'blue',
        verbose = verbose)

    # metrics and plots to generate #####
    metrics.table <- all.metrics$final.metrics.table

    ## RLE #####
    ### compute rle #####
    if('RLE' %in% metrics.table$Metrics){
        if('General' %in% metrics.table$Factors &
           'rleMedians' %in% metrics.table$Factors &
           'rleIqr' %in% metrics.table$Factors ){
            rle.outputs.to.return <- 'all'
        }
        if(!'General' %in% metrics.table$Factors &
           'rleMedians' %in% metrics.table$Factors &
           'rleIqr' %in% metrics.table$Factors ){
            rle.outputs.to.return <- 'rle.med.iqr'
        }
        se.obj <- computeRLE(
            se.obj = se.obj,
            assay.names = assay.names,
            apply.log = apply.log,
            pseudo.count = pseudo.count,
            outputs.to.return = rle.outputs.to.return,
            assess.se.obj = FALSE,
            remove.na = 'none',
            save.se.obj = TRUE,
            verbose = verbose)
        }

    ### plot general rle #####
    if('RLEplot' %in% metrics.table$PlotTypes){
        se.obj <- plotRLE(
            se.obj = se.obj,
            assay.names = assay.names,
            variable = NULL,
            ylim.rle.plot = NULL,
            iqr.width = 1,
            median.points.size = 1,
            median.points.color = "red",
            geom.hline.color = "cyan",
            plot.ncol = 1,
            plot.output = FALSE,
            save.se.obj = TRUE,
            verbose = verbose)
    }

    ### plot colored rle #####
    if('coloredRLEplot' %in% metrics.table$PlotTypes){
        coloredRLEplot.vars <- metrics.table$PlotTypes == 'coloredRLEplot'
        coloredRLEplot.vars <- metrics.table$Variables[coloredRLEplot.vars]
        for(i in coloredRLEplot.vars){
            se.obj <- plotRLE(
                se.obj = se.obj,
                assay.names = assay.names,
                variable = i,
                ylim.rle.plot = NULL,
                iqr.width = 1,
                median.points.size = 1,
                median.points.color = "grey",
                geom.hline.color = "cyan",
                plot.ncol = 1,
                plot.output = FALSE,
                save.se.obj = TRUE,
                verbose = verbose)
        }
    }
    ### plot rle medians with variable #####
    if('rleMedians' %in% metrics.table$Factors){
        index <- metrics.table$Factors == 'rleMedians'
        rleMedplot.vars <- metrics.table$Variables[index]
        for(i in rleMedplot.vars){
            se.obj <- plotRleVariable(
                se.obj = se.obj,
                assay.names = assay.names,
                variable = i,
                rle.data.type = 'rle.medians',
                ylim.rle.med.plot = NULL,
                ylim.rle.iqr.plot = NULL,
                points.size = 1,
                plot.ncol = 2,
                plot.output = FALSE,
                save.se.obj = TRUE,
                verbose = verbose)
        }
    }

    ### plot rle iqr with variable #####
    if('rleIqr' %in% metrics.table$Factors){
        rleIqrplot.vars <- metrics.table$Factors == 'rleIqr'
        rleIqrplot.vars <- metrics.table$Variables[rleIqrplot.vars]
        for(i in rleIqrplot.vars){
            se.obj <- plotRleVariable(
                se.obj = se.obj,
                assay.names = assay.names,
                variable = i,
                rle.data.type = 'rle.iqr',
                ylim.rle.med.plot = NULL,
                ylim.rle.iqr.plot = NULL,
                points.size = 1,
                plot.ncol = 2,
                plot.output = FALSE,
                save.se.obj = TRUE,
                verbose = verbose)
        }
    }

    ## PCA ####
    ### compute pca ####
    if('PCA' %in% metrics.table$Metrics){
        se.obj <- computePCA(
            se.obj = se.obj,
            assay.names = assay.names,
            fast.pca = fast.pca,
            nb.pcs = compute.nb.pcs,
            center = center.pca,
            scale = scale.pca,
            apply.log = apply.log,
            pseudo.count = pseudo.count,
            svd.bsparam = svd.bsparam,
            assess.se.obj = FALSE,
            remove.na = 'none',
            save.se.obj = TRUE,
            verbose = verbose)
    }
    ### scatter plot pca ####
    if('PCA' %in% metrics.table$Metrics & 'scatterPlot' %in% metrics.table$PlotTypes){
        index <- metrics.table$Metrics == 'PCA' & metrics.table$PlotTypes == 'scatterPlot'
        pca.scatter.vars <- metrics.table$Variables[index]
        for(i in pca.scatter.vars){
            se.obj <- plotPCA(
                se.obj = se.obj,
                assay.names = assay.names,
                variable = i,
                fast.pca = fast.pca,
                nb.pcs = nb.pcs.toplot.pca,
                plot.type = "scatter",
                points.size = 1,
                stroke.color = "gray30",
                stroke.size = 0.2,
                points.alpha = 0.5,
                densities.alpha = 0.5,
                plot.ncol = 1,
                save.se.obj = TRUE,
                verbose = TRUE)
        }
    }
    ### boxplot pca ####
    if('PCA' %in% metrics.table$Metrics & 'boxPlot' %in% metrics.table$PlotTypes){
        index <- metrics.table$Metrics == 'PCA' & metrics.table$PlotTypes == 'boxPlot'
        pca.boxplot.vars <- metrics.table$Variables[index]
        for(i in pca.boxplot.vars){
            se.obj <- plotPCA(
                se.obj = se.obj,
                assay.names = assay.names,
                variable = i,
                fast.pca = fast.pca,
                nb.pcs = nb.pcs.toplot.pca,
                plot.type = "boxplot",
                points.size = 1,
                stroke.color = "gray30",
                stroke.size = 0.2,
                points.alpha = 0.5,
                densities.alpha = 0.5,
                plot.ncol = 4,
                save.se.obj = TRUE,
                verbose = TRUE)
        }
    }

    ## Vector correlation ####
    ### compute vector correlation ####
    if('PcaVecCorr' %in% metrics.table$Metrics){
        index <- metrics.table$Metrics == 'PcaVecCorr'
        pc.vec.corr.vars <- metrics.table$Variables[index]
        for(i in pc.vec.corr.vars){
            se.obj <- computePCVariableCorrelation(
                se.obj = se.obj,
                assay.names = assay.names,
                variable = i,
                fast.pca = fast.pca,
                nb.pcs = compute.nb.pcs,
                save.se.obj = TRUE,
                verbose = verbose)
        }
    }
    ### plot vector correlation ####
    if('PcaVecCorr' %in% metrics.table$Metrics){
        index <- metrics.table$Metrics == 'PcaVecCorr'
        pc.vec.corr.vars <- metrics.table$Variables[index]
        for(i in pc.vec.corr.vars){
            se.obj <- plotPCVariableCorrelation(
                se.obj = se.obj,
                assay.names = assay.names,
                variable = i,
                fast.pca = fast.pca,
                nb.pcs = compute.nb.pcs,
                plot.output = FALSE,
                save.se.obj = TRUE,
                verbose = verbose)
        }
    }

    ## Linear regression ####
    ### compute linear regression ####
    if('PcaReg' %in% metrics.table$Metrics){
        index <- metrics.table$Metrics == 'PcaReg'
        pc.reg.vars <- metrics.table$Variables[index]
        for(i in pc.reg.vars){
            se.obj <- computePCVariableRegression(
                se.obj = se.obj,
                assay.names = assay.names,
                variable = i,
                fast.pca = fast.pca,
                nb.pcs = compute.nb.pcs,
                save.se.obj = TRUE,
                verbose = verbose)
        }
    }
    ### plot linear regression ####
    if('PcaReg' %in% metrics.table$Metrics){
        index <- metrics.table$Metrics == 'PcaReg'
        pc.reg.vars <- metrics.table$Variables[index]
        for(i in pc.reg.vars){
            se.obj <- plotPCVariableRegression(
                se.obj = se.obj,
                assay.names = assay.names,
                variable = i,
                fast.pca = fast.pca,
                nb.pcs = compute.nb.pcs,
                plot.output = FALSE,
                save.se.obj = TRUE,
                verbose = verbose)
        }
    }

    ## Silhouette coefficient ####
    ### compute silhouette coefficients ####
    if('Silhouette' %in% metrics.table$Metrics){
        index.single <- metrics.table$Metrics == 'Silhouette' &
            metrics.table$PlotTypes == 'barPlot'
        sil.single.vars <- metrics.table$Variables[index.single]
        index.combined <- metrics.table$Metrics == 'Silhouette' &
            metrics.table$PlotTypes == 'combinedPlot'
        sil.combined.vars <- metrics.table$Variables[index.combined]
        sil.combined.vars <- unlist(strsplit(x = sil.combined.vars, split = '&'))
        all.sil.vars <- unique(c(sil.single.vars, sil.combined.vars))
        for(i in all.sil.vars){
            se.obj <- computeSilhouette(
                se.obj = se.obj,
                assay.names = assay.names,
                variable = i,
                dist.measure = sil.dist.measure,
                fast.pca = fast.pca,
                nb.pcs = sil.nb.pcs,
                save.se.obj = TRUE,
                verbose = verbose)
        }
    }
    ### barplot silhouette coefficients  ####
    if('Silhouette' %in% metrics.table$Metrics & 'barPlot' %in% metrics.table$PlotTypes){
        index <- metrics.table$Metrics == 'Silhouette' & metrics.table$PlotTypes == 'barPlot'
        sil.single.vars <- metrics.table$Variables[index]
        for(i in sil.single.vars){
            se.obj <- plotSilhouette(
                se.obj = se.obj,
                assay.names = assay.names,
                variables = i,
                plot.type = 'single.plot',
                silhouette.method = 'sil.euclidian',
                plot.output = FALSE,
                save.se.obj = TRUE,
                verbose = verbose)
        }
    }
    ### combined plot silhouette coefficients  ####
    if('Silhouette' %in% metrics.table$Metrics & 'combinedPlot' %in% metrics.table$PlotTypes){
        index <- metrics.table$Metrics == 'Silhouette' & metrics.table$PlotTypes == 'combinedPlot'
        sil.combined.vars <- metrics.table$Variables[index]
        for(i in sil.combined.vars){
            se.obj <- plotSilhouette(
                se.obj = se.obj,
                assay.names = assay.names,
                variables = strsplit(x = i, split = '&')[[1]],
                plot.type = 'combined.plot',
                silhouette.method = 'sil.euclidian',
                plot.output = FALSE,
                save.se.obj = TRUE,
                verbose = verbose)
        }
    }

    ## ARI ####
    ### compute adjusted rand index ####
    if('ARI' %in% metrics.table$Metrics){
        index.single <- metrics.table$Metrics == 'ARI' &
            metrics.table$PlotTypes == 'barPlot'
        ari.single.vars <- metrics.table$Variables[index.single]
        index.combined <- metrics.table$Metrics == 'ARI' &
            metrics.table$PlotTypes == 'combinedPlot'
        ari.combined.vars <- metrics.table$Variables[index.combined]
        ari.combined.vars <- unlist(strsplit(x = ari.combined.vars, split = '&'))
        all.ari.vars <- unique(c(ari.single.vars, ari.combined.vars))
        for(i in all.ari.vars){
            se.obj <- computeARI(
                se.obj = se.obj,
                assay.names = assay.names,
                variable = i,
                clustering.method = ari.clustering.method,
                hclust.method = ari.hclust.method,
                hclust.dist.measure = ari.hclust.dist.measure,
                fast.pca = fast.pca,
                nb.pcs = ari.nb.pcs,
                save.se.obj = TRUE,
                verbose = verbose)
        }
    }
    ### barplot adjusted rand index  ####
    if('ARI' %in% metrics.table$Metrics & 'barPlot' %in% metrics.table$PlotTypes){
        index <- metrics.table$Metrics == 'ARI' & metrics.table$PlotTypes == 'barPlot'
        ari.single.vars <- metrics.table$Variables[index]
        for(i in ari.single.vars){
            se.obj <- plotARI(
                se.obj = se.obj,
                assay.names = assay.names,
                variables = i,
                plot.type = 'single.plot',
                ari.method = 'hclust.complete.euclidian',
                plot.output = FALSE,
                save.se.obj = TRUE,
                verbose = verbose)
        }
    }
    ### combined adjusted rand index  ####
    if('ARI' %in% metrics.table$Metrics & 'combinedPlot' %in% metrics.table$PlotTypes){
        index <- metrics.table$Metrics == 'ARI' & metrics.table$PlotTypes == 'combinedPlot'
        ari.combined.vars <- metrics.table$Variables[index]
        for(i in ari.combined.vars){
            se.obj <- plotARI(
                se.obj = se.obj,
                assay.names = assay.names,
                variables = strsplit(x = i, split = '&')[[1]],
                plot.type = 'combined.plot',
                ari.method = 'hclust.complete.euclidian',
                plot.output = FALSE,
                save.se.obj = TRUE,
                verbose = verbose)
        }
    }

    ## Gene variable correlation ####
    ### compute gene variable correlations ####
    if('GeneVarCorr' %in% metrics.table$Metrics){
        index <- metrics.table$Metrics == 'GeneVarCorr'
        gene.var.corr.vars <- metrics.table$Variables[index]
        for(i in gene.var.corr.vars){
            se.obj <- computeGenesVariableCorrelation(
                se.obj = se.obj,
                assay.names = assay.names,
                variable = i,
                method = corr.method,
                a = 0.05,
                rho = 0,
                plot.top.genes = FALSE,
                nb.top.genes = NULL,
                apply.log = apply.log,
                pseudo.count = pseudo.count,
                apply.round = TRUE,
                assess.se.obj = FALSE,
                remove.na = 'none',
                save.se.obj = TRUE)
        }
    }
    ### plot gene variable correlations ####
    if('GeneVarCorr' %in% metrics.table$Metrics){
        index <- metrics.table$Metrics == 'GeneVarCorr'
        gene.var.corr.vars <- metrics.table$Variables[index]
        for(i in gene.var.corr.vars){
            se.obj <- plotGenesVariableCorrelation(
                se.obj = se.obj,
                assay.names = assay.names,
                variable = i,
                correlation.method = 'gene.spearman.corr',
                plot.output = FALSE,
                save.se.obj = TRUE,
                verbose = verbose)
            }
    }

    ## Gene variable anova ####
    ### compute gene variable anova ####
    if('GeneVarAov' %in% metrics.table$Metrics){
        index <- metrics.table$Metrics == 'GeneVarAov'
        gene.var.anova.vars <- metrics.table$Variables[index]
        for(i in gene.var.anova.vars){
            se.obj <- computeGenesVariableAnova(
                se.obj = se.obj,
                assay.names = assay.names,
                variable = i,
                method = anove.method,
                plot.top.genes = FALSE,
                nb.top.genes = NULL,
                apply.log = apply.log,
                pseudo.count = pseudo.count,
                apply.round = TRUE,
                assess.se.obj = FALSE,
                remove.na = 'none',
                save.se.obj = TRUE)
        }
    }
    ### plot gene variable anova ####
    if('GeneVarAov' %in% metrics.table$Metrics){
        index <- metrics.table$Metrics == 'GeneVarAov'
        gene.var.corr.vars <- metrics.table$Variables[index]
        for(i in gene.var.corr.vars){
            se.obj <- plotGenesVariableAnova(
                se.obj = se.obj,
                assay.names = assay.names,
                variable = i,
                anova.method = "genes.aov.anova",
                plot.output = FALSE,
                save.se.obj = TRUE,
                verbose = TRUE)
        }
    }

    ## DGE ####
    ### compute dge ####
    if('DGE' %in% metrics.table$Metrics){
        index <- metrics.table$Metrics == 'DGE'
        dge.vars <- metrics.table$Variables[index]
        for(i in dge.vars){
            se.obj <- computeDGE(
                se.obj = se.obj,
                assay.names = assay.names,
                variable = i,
                apply.log = apply.log,
                pseudo.count = pseudo.count,
                assess.se.obj = FALSE,
                remove.na = 'none',
                save.se.obj = TRUE,
                verbose = verbose)
        }
    }
    ### plot p value hist ####
    if('DGE' %in% metrics.table$Metrics){
        index <- metrics.table$Metrics == 'DGE'
        dge.vars <- metrics.table$Variables[index]
        for(i in dge.vars){
            se.obj <- plotDGE(
                se.obj = se.obj,
                assay.names = assay.names,
                variable = i,
                plot.ncol = 1,
                plot.output = FALSE,
                save.se.obj = TRUE,
                verbose = verbose)
        }
    }

    # save all plots ####
    mytheme <- gridExtra::ttheme_default(
        core = list(fg_params=list(cex = 1)),
        colhead = list(fg_params=list(cex = 1)),
        rowhead = list(fg_params=list(cex = 1)))
    pdf('RUVIIIPRPS_R_Package.pdf')
    plot.new()
    text(.5, .5, "Assess variation", font = 2, cex = 1.5)
    grid.table(metrics.table, theme = mytheme)

    if('General' %in% metrics.table$Variables  & 'RLEplot' %in% metrics.table$PlotTypes){
        print(se.obj@metadata$plot$RLE$GeneralRLE)
    }
    for(i in continuous.vars){
        plot.new()
        text(.5, .9, paste0("Assess variation in the variable", i ), font = 2, cex = 1.5)
        metrics.table.var <- metrics.table[metrics.table$Variables == i, ]
        grid.table(metrics.table, theme = mytheme)
        for(j in 1:nrow(metrics.table.var)){
            if(metrics.table.var$Factors[j] == 'rleMedians'){
                print(se.obj@metadata$plot$RLE[[i]]$RleVarPlot$RleMedians)
            }
            if(metrics.table.var$Factors[j] == 'rleIqr'){
                print(se.obj@metadata$plot$RLE[[i]]$RleVarPlot$RleIqr)
            }
            if(metrics.table.var$Factors[j] == 'pcs' & metrics.table.var$Metrics[j] == 'PCA'){
                print(se.obj@metadata$plot$PCA$fastPCA[[i]]$ScatVarPCA)
            }
            if(metrics.table.var$Factors[j] == 'pcs' & metrics.table.var$Metrics[j] == 'PcaReg'){
                print(se.obj@metadata$plot$PcaReg[[i]])
            }
            if(metrics.table.var$Factors[j] == 'geneCorr'){
                print(se.obj@metadata$plot$GeneVarCorr$gene.spearman.corr[[i]])
            }
        }
    }
    for(i in categorical.vars){
        plot.new()
        text(.5, .5, paste0(i , " Assess variation"), font = 2, cex = 1.5)
        metrics.table.var <- metrics.table[metrics.table$Variables == i, ]
            if('coloredRLEplot' %in% metrics.table.var$PlotTypes){
                print(se.obj@metadata$plot$RLE[[i]]$ColoredRLE)
            }
            if('rleMedians' %in% metrics.table.var$Factors){
                print(se.obj@metadata$plot$RLE[[i]]$RleVarPlot$RleMedians)
            }
            if('rleIqr' %in% metrics.table.var$Factors){
                print(se.obj@metadata$plot$RLE[[i]]$RleVarPlot$RleIqr)
            }
            if('pcsboxPlot' %in% paste0(metrics.table.var$Factors, metrics.table.var$PlotTypes) ){
                print(se.obj@metadata$plot$PCA$fastPCA[[i]]$BoxPCA)
            }
            if('pcsscatterPlot' %in% paste0(metrics.table.var$Factors, metrics.table.var$PlotTypes)){
                print(se.obj@metadata$plot$PCA$fastPCA[[i]]$ScatPCA)
            }
            if( 'PcaVecCorr' %in% metrics.table.var$Metrics ){
                print(se.obj@metadata$plot$VecCorr[[i]])
            }
            if('ARI' %in% metrics.table.var$Metrics ){
                print(se.obj@metadata$plot$ARI$hclust.complete.euclidian$ari.single.plot[[i]])
            }
            if('silhouetteCoeff' %in% metrics.table.var$Factors ){
                print(se.obj@metadata$plot$Silhouette$sil.euclidian[[i]])
            }
            if('geneAnov' %in% metrics.table.var$Factors ){
                print(se.obj@metadata$plot$GeneVarAnova$genes.aov.anova[[i]])
            }
            if('pvaluse' %in% metrics.table.var$Factors ){
                print(se.obj@metadata$plot$DEG[[i]])
            }
    }
    dev.off()
    printColoredMessage(message = '------------The normAssessment function finished.',
                        color = 'white',
                        verbose = verbose)
    return(se.obj)
}
